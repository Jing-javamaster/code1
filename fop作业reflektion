fop02-

H2.1.2
1.坐标搞错
2.没有直接写turnRight方法，导致复杂化
3.放硬币多个没有写方法，复杂化
4.先前代码因为while循环坐标判断条件一直被跳过所以没有放硬币

H2.2
1.没有什么是一步一步完成不了的，想要一口吃成大胖子才是不可能的：不要想着写出一个方法能够完美应对所有情况，而是有一个情况写一个对应方法
2.先确定方向，再细化细节，题目没那么难，不要自己复杂化了
3.边界的Ausweichen针对处理
4.边界是(0-WORLD.SIZE-1)



fop03-
1.一旦 Java 程序执行到 return 语句，就会立即结束整个方法的执行，
后面的所有代码（包括循环、最后的 return true;）都不会再运行。



fop04-
1.在写子类extend到父类的时候，父类当中有abstract方法，子类要么实现这个方法，要么也成为abstract
2.子类在调用父类构造器的时候，父类没有默认，子类一开始要super()
3.子类super可以不用照搬父类的参数
  父类需要 4 个参数没错（你必须给它）
	•	但作为子类，你可以决定其中某些参数的默认值
	•	所以子类构造器没必要暴露所有父类参数
比如：
父类是：protected Participant(Species species, int x, int y, Direction orientation) {}
子类：public Scissors(int x,int y){
        super(Species.SCISSORS,x,y, Direction.UP);
    }
也就是所谓的子类可以决定某些参数的默认值

4.两个你死我活，返回活的那个，三元运算符 我死？你：我；
5.‼️注意 getDirection和getOrientation不同，注意看类中的方法
6.每次完成一个部分就执行一次Main看效果调整代码，否则后期定位困难




fop05-
1.
接口A extends 接口B
类C implements A（‼️也就是类C要实现A+B的所有方法）
🤔如果此时有多个C，也就是有多个拥有共同实现的类C，此时引入一个AbstractB类，只用在这个类中实现，让所有类C extends这个类就好了



2.在什么情况下需要import？
名字不完全相同 → 就是不同包 → 必须 import。
也就是：
只要 package 名字不完全一样 → 就必须 import
