fop02-

H2.1.2
1.坐标搞错
2.没有直接写turnRight方法，导致复杂化
3.放硬币多个没有写方法，复杂化
4.先前代码因为while循环坐标判断条件一直被跳过所以没有放硬币

H2.2
1.没有什么是一步一步完成不了的，想要一口吃成大胖子才是不可能的：不要想着写出一个方法能够完美应对所有情况，而是有一个情况写一个对应方法
2.先确定方向，再细化细节，题目没那么难，不要自己复杂化了
3.边界的Ausweichen针对处理
4.边界是(0-WORLD.SIZE-1)



fop03-
1.一旦 Java 程序执行到 return 语句，就会立即结束整个方法的执行，
后面的所有代码（包括循环、最后的 return true;）都不会再运行。



fop04-
1.在写子类extend到父类的时候，父类当中有abstract方法，子类要么实现这个方法，要么也成为abstract
2.子类在调用父类构造器的时候，父类没有默认，子类一开始要super()
3.子类super可以不用照搬父类的参数
  父类需要 4 个参数没错（你必须给它）
	•	但作为子类，你可以决定其中某些参数的默认值
	•	所以子类构造器没必要暴露所有父类参数
比如：
父类是：protected Participant(Species species, int x, int y, Direction orientation) {}
子类：public Scissors(int x,int y){
        super(Species.SCISSORS,x,y, Direction.UP);
    }
也就是所谓的子类可以决定某些参数的默认值

4.两个你死我活，返回活的那个，三元运算符 我死？你：我；
5.‼️注意 getDirection和getOrientation不同，注意看类中的方法
6.每次完成一个部分就执行一次Main看效果调整代码，否则后期定位困难




fop05-
1.
接口A extends 接口B
类C implements A（‼️也就是类C要实现A+B的所有方法）
🤔如果此时有多个C，也就是有多个拥有共同实现的类C，此时引入一个AbstractB类，只用在这个类中实现，让所有类C extends这个类就好了

2.在什么情况下需要import？
名字不完全相同 → 就是不同包 → 必须 import。
也就是：
只要 package 名字不完全一样 → 就必须 import

3.“在构造器里初始化”是什么意思？
你声明了一个字段之后，必须在类的构造方法（constructor）里给它赋值。

private final double capacity;
public Powerbank(double capacity) {
    this.capacity = capacity;
}

4.实现一个接口，也就是实现这个接口+它上面所有extends的接口
判断一个方法是否需要自己写：‼️‼️
看你的类 implements 的每一个接口里：
这个方法是否已经有 default 实现。
有就不用

5.if替换成switch的情况
在什么情况下switch比if更适用❓ 「根据对象的类型」」来决定行为的时候
🤔而 if 更适合：
	•	复杂条件
	•	多重比较
	•	不可枚举的逻辑
	•	需要 boolean 表达式、范围判断
Folien03b中讲了instanceof
03c中讲了switch 
216讲了需要break的一种写法
228讲了一种‼️不需要break的一种写法

6.instanceof
作用：判断某个对象是否属于某个类（或接口）的类型。

7.某点(x,y)半径r以内的正方形
超过地图的点不要
int width;
int height;
for(int i = -r; i <= r; i++){
	for(int j = -r; j <= r; j++){
		int ii = i + x;
		int jj = j + x;
		if(ii < 0 || ii > width || jj < 0 || jj > height){
			continue;///当前点不要啦
		}
		add(ii,jj);///如果在地图内，就要这个点
	}
}

8.需要返回一个不知道长度的数组Point[]
使用了ArrayList<Point> list = new ArrayList<>();
为什么？🤔
‼️数组（Point[]）必须在创建时就知道“确切长度”，这里我们因为有continue，也就不能确定确切长度
‼️ArrayList 是“可变长的容器”（动态数组）
你加多少个 Java 都会自动分配内存，并把数据存进去。
你完全不用提前知道“要存多少个点”。
这就是它存在的原因。
‼️ArrayList 和 List 的区别是什么？
	•	List 是接口（规则）
	•	ArrayList 是实现类（具体容器）
‼️什么时候应该用 ArrayList 来替代数组？
当你不知道最终项的数量，或者项是动态变化时，用 ArrayList。
当你已经知道确切长度，并且不会改变时，用数组。

9.void方法当中可以写return
写了 return; → 你可以中途提前退出，不继续后面的逻辑
不写 return → 方法会执行完所有代码自动结束
⚠️但是不能return某个值，也就是说在void语句当中使用return仅仅为了提早结束代码

10.还是有必要每一个代码都检查一遍



fop06-
1.由于对象常量必须在构造函数中初始化，你必须创建一个公共构造器，将 TransportType 对象作为形式参数并用它初始化 transportType。
public MeansOfTransport(TransportType transportType) {
    this.transportType = transportType;
}❓不理解
1️⃣构造器的作用只有一个：
当别人 new 这个类时，用来初始化对象的字段。也就是说人家在new一个这个类的新对象的时候，那构造器就负责把传进来的 TransportType 保存到这个对象里。
对象里面的 transportType   =   调用构造器时传进来的 transportType

2.后面说对象常量必须在构造器当中initialisieren，那为什么实际还是写在构造器之外？
‼️初始化和声明不同：初始化-赋值，声明-不赋值
final 字段必须“在构造器里赋值”，但字段本身必须“在类里面声明
且构造器本身是为了初始化对象的字段的，不是声明字段用‼️













