fop02-

H2.1.2
1.坐标搞错
2.没有直接写turnRight方法，导致复杂化
3.放硬币多个没有写方法，复杂化
4.先前代码因为while循环坐标判断条件一直被跳过所以没有放硬币

H2.2
1.没有什么是一步一步完成不了的，想要一口吃成大胖子才是不可能的：不要想着写出一个方法能够完美应对所有情况，而是有一个情况写一个对应方法
2.先确定方向，再细化细节，题目没那么难，不要自己复杂化了
3.边界的Ausweichen针对处理
4.边界是(0-WORLD.SIZE-1)



fop03-
1.一旦 Java 程序执行到 return 语句，就会立即结束整个方法的执行，
后面的所有代码（包括循环、最后的 return true;）都不会再运行。



fop04-
1.在写子类extend到父类的时候，父类当中有abstract方法，子类要么实现这个方法，要么也成为abstract
2.子类在调用父类构造器的时候，父类没有默认，子类一开始要super()
3.子类super可以不用照搬父类的参数
  父类需要 4 个参数没错（你必须给它）
	•	但作为子类，你可以决定其中某些参数的默认值
	•	所以子类构造器没必要暴露所有父类参数
比如：
父类是：protected Participant(Species species, int x, int y, Direction orientation) {}
子类：public Scissors(int x,int y){
        super(Species.SCISSORS,x,y, Direction.UP);
    }
也就是所谓的子类可以决定某些参数的默认值

4.两个你死我活，返回活的那个，三元运算符 我死？你：我；
5.‼️注意 getDirection和getOrientation不同，注意看类中的方法
6.每次完成一个部分就执行一次Main看效果调整代码，否则后期定位困难




fop05-
1.
接口A extends 接口B
类C implements A（‼️也就是类C要实现A+B的所有方法）
🤔如果此时有多个C，也就是有多个拥有共同实现的类C，此时引入一个AbstractB类，只用在这个类中实现，让所有类C extends这个类就好了

2.在什么情况下需要import？
名字不完全相同 → 就是不同包 → 必须 import。
也就是：
只要 package 名字不完全一样 → 就必须 import

3.“在构造器里初始化”是什么意思？
你声明了一个字段之后，必须在类的构造方法（constructor）里给它赋值。

private final double capacity;
public Powerbank(double capacity) {
    this.capacity = capacity;
}

4.实现一个接口，也就是实现这个接口+它上面所有extends的接口
判断一个方法是否需要自己写：‼️‼️
看你的类 implements 的每一个接口里：
这个方法是否已经有 default 实现。
有就不用

5.if替换成switch的情况
在什么情况下switch比if更适用❓ 「根据对象的类型」」来决定行为的时候
🤔而 if 更适合：
	•	复杂条件
	•	多重比较
	•	不可枚举的逻辑
	•	需要 boolean 表达式、范围判断
Folien03b中讲了instanceof
03c中讲了switch 
216讲了需要break的一种写法
228讲了一种‼️不需要break的一种写法

6.instanceof
作用：判断某个对象是否属于某个类（或接口）的类型。

7.某点(x,y)半径r以内的正方形
超过地图的点不要
int width;
int height;
for(int i = -r; i <= r; i++){
	for(int j = -r; j <= r; j++){
		int ii = i + x;
		int jj = j + x;
		if(ii < 0 || ii > width || jj < 0 || jj > height){
			continue;///当前点不要啦
		}
		add(ii,jj);///如果在地图内，就要这个点
	}
}

8.需要返回一个不知道长度的数组Point[]
使用了ArrayList<Point> list = new ArrayList<>();
为什么？🤔
‼️数组（Point[]）必须在创建时就知道“确切长度”，这里我们因为有continue，也就不能确定确切长度
‼️ArrayList 是“可变长的容器”（动态数组）
你加多少个 Java 都会自动分配内存，并把数据存进去。
你完全不用提前知道“要存多少个点”。
这就是它存在的原因。
‼️ArrayList 和 List 的区别是什么？
	•	List 是接口（规则）
	•	ArrayList 是实现类（具体容器）
‼️什么时候应该用 ArrayList 来替代数组？
当你不知道最终项的数量，或者项是动态变化时，用 ArrayList。
当你已经知道确切长度，并且不会改变时，用数组。

9.void方法当中可以写return
写了 return; → 你可以中途提前退出，不继续后面的逻辑
不写 return → 方法会执行完所有代码自动结束
⚠️但是不能return某个值，也就是说在void语句当中使用return仅仅为了提早结束代码

10.还是有必要每一个代码都检查一遍



fop06-
1.由于对象常量必须在构造函数中初始化，你必须创建一个公共构造器，将 TransportType 对象作为形式参数并用它初始化 transportType。
public MeansOfTransport(TransportType transportType) {
    this.transportType = transportType;
}❓不理解
1️⃣构造器的作用只有一个：
当别人 new 这个类时，用来初始化对象的字段。也就是说人家在new一个这个类的新对象的时候，那构造器就负责把传进来的 TransportType 保存到这个对象里。
对象里面的 transportType   =   调用构造器时传进来的 transportType

2.后面说对象常量必须在构造器当中initialisieren，那为什么实际还是写在构造器之外？
‼️初始化和声明不同：初始化-赋值，声明-不赋值
final 字段必须“在构造器里赋值”，但字段本身必须“在类里面声明
且构造器本身是为了初始化对象的字段的，不是声明字段用‼️


3.‼️‼️构造器的用法
构造器当中初始化字段（通过传进来的参数），因为这些字段是作为一个后续在我们创建对象的时候给人家初始化用的值。
初始化的字段来源于 这个类（以及它的父类）中定义的字段。
字段在本类声明 → 用 this.field = parameter;
字段在父类声明 → 用 super(parameter);

4.static final和final的区别‼️
“Klasssenkonstante” = 类常量 = static final
不是对象常量。

类型							写法				作用范围				属于对象？
对象常量（Objektkonstante）	final			每个对象自己的值		✔
类常量（Klassenkonstante）	static final	整个类共享			❌


5.protected的范围
同一个包当中类+所有的子类（跨包也可以）

也就是说 protected 同时满足两条：
	1.	包可见性（同包都能访问）
	2.	继承可见性（子类都能访问）
任何一个成立，就能访问。



6.implement（实现）只能发生在：
	•	类 implements 接口
	•	接口 extends 接口
	•	类 extends 类
	•	类 extends 抽象类


6.1 remainingWood的原理是理解难点，有很多地方需要兼顾：比如减去1后是否为0，如果为0还要将原数组的index0设置成这个。


7.substring(int a, int b)是取从a开始到b-1

8.replaceToken的原理：
首先是indexOf占位符<>的位置，然后取出他们中间的token，
通过tokenDictionary的lookup方法找到应该用什么字符替代，该替代字符为replacement，
然后再把整个String当中，占位符两侧的部分取出（不含占位符），
然后再把三个部分：占位符左侧字符+replacement+占位符右侧字符，合起来return 这就是这个replaceToken的运行原理




fop07-
1.关于recursive Aufruf
递归 = 函数自己调用自己。

‼️那怎么知道什么时候停？
✅ 递归靠“终止条件（base case）”停下来。
如果没有终止条件，递归会永远调用自己，最终导致 StackOverflowError（爆栈）。
终止条件就是：当满足某个条件时，不再调用自己，而是直接 return。

所以一个递归能“停”的两个必要条件：
1️⃣必须有终止条件（base case）
2️⃣每次递归必须往“更小的状态”走



2.Iterative和Rekursive的区别
1️⃣Iterative：
靠 循环 重复执行：
for
while
do-while
2️⃣Rekursiv（递归）
靠 方法调用自己 重复执行：




3.Racket当中list-ref是Array当中的查询，比如list-ref Array 1相等于Array[1]





4.rekursive和iteration的互相转换
1️⃣递归（rekursiv）
	•	函数 / 方法自己调自己。
	•	必须有两个东西：
	1.	Basisfall：最小情况，直接返回。
	2.	Rekursionsschritt：把大问题变小，丢给自己。
2️⃣迭代（iterativ）
	•	用 for / while 循环，一步一步更新变量。
	•	不再“自己调用自己”，而是用变量来保存“现在走到哪一步了”。

‼️‼️关键认识：递归和迭代做的是 同一件事：“不断做同样的一步操作，直到满足结束条件”。
区别只是：
	•	递归：由调用栈帮你记住“做到哪一步了”。
	•	迭代：由你自己声明的变量帮你记住“做到哪一步了”。
你现在“转不过弯”的地方，通常就是：‼️没有清晰看到：递归里哪几个东西，对应迭代里的“循环变量”和“累加结果”。

举例：
（Rekursive）
int factRec(int n) {
    if (n == 0) {        // Basisfall
        return 1;
    }
    return n * factRec(n - 1);   // Rekursionsschritt
}

（Iterative）
int factIter(int n) {
    int result = 1;           // 对应“到目前为止的结果”
    int i = 1;                // 对应“走到第几步了”
    while (i <= n) {
        result = result * i;  // 做一步
        i = i + 1;            // 变小/变大一点
    }
    return result;
}






fop08-
1.所谓的树结构和我们上一份练习当中的Racket几乎一模一样
把算术表达式用树结构表示出来（‼️节点里存操作，子节点是操作数/子表达式）

2.functional Interface和Lambda
1️⃣Functional interface = ‼️一个“只描述函数长什么样”的接口
关键规则（这是 functional interface 的核心）：一个 interface 里，只允许有一个抽象方法
也就是说：
	•	一个接口
	•	只定义一个函数签名
	•	不写实现
这就是“functional”。

2️⃣Lambda 只是实现这个接口的一种写法。
不用lambda：								用了lambda：
IntToInt f = new IntToInt() {			IntToInt f = x -> x + 1;
    @Override
    public int apply(int x) {
        return x + 1;
    }
};
Lambda 的本质（非常重要）：lambda ‼️不是“新概念”，它只是：“帮你写掉那一大坨 anonymous class 的语法糖”








fop11-
遍历变量的更新vs链表结构的更新
🌰为什么只需要 tail = prev，不需要写 prev = current？
‼️因为：
	•	tail = prev 是在改链表的成员变量 tail，让链表尾指针正确。
	•	prev = current 这种写法只是在改你方法里的局部变量 prev，不会改变链表结构，离开方法就没意义。
换句话说：
链表换位置要改的是节点之间的 .next 关系，以及 head/tail 这种“入口/出口指针”，不是改局部变量名指向谁。

所以“下半句不用写”是因为它对链表没任何作用。









