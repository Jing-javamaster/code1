<img width="200" height="188" alt="image" src="https://github.com/user-attachments/assets/2d91beee-cd08-4b0d-a3ab-46691f64c3dd" /># code1
uebungen




9.27
super关键字
W3上的练习+文字
微信群的理解
总结









override重写
bili的练习





9.28
多态
规范作用，延展性强




final关键字



9.29
✅抽象已练习
abstract
抽象：在java中只声明，不实现（没有具体实现）

抽象类：如果一个类中有抽象方法，这个类必须是一个抽象类，但是抽象类可以有正常方法
特点：
1.不可以创建对象（对应不实现）
2.抽象类的子类，必须重写父类中的抽象方法，否则，子类必须也是抽象类。（意思是如果子类想要不是抽象类，必须得重写父类中的抽象方法--去abstract，如果不重写，方法为抽象，那么子类也必须为抽象类）
通过抽象类可以强制要求子类中必须有哪些方法，因为子类要继承父类，所以必须所有的方法在子类中都重写一遍（即去abstract）

抽象方法：用abstrct来修饰，不可以有方法体，直接用分号结束即可

但其实不是不实现，而是不在抽象里面实现，在子类里执行：通过子类的继承，因为重写了方法（去abstract）所以子类的方法是实现的，是可以有方法体的，所以
那么抽象类起到什么作用：规范作用



父类子类和抽象类、接口的关系
	•	接口 (interface) 是纯粹的规范，没有任何实现（直到 Java 8 加了 default 方法，但本质还是规范为主）。
	•	抽象类 (abstract class) 是“接口 + 部分实现”。
	•	父类（普通类） 可以没有抽象方法，完全就是复用代码的“基类”。

所以边界可以这么划：
	•	接口：定义能力（“你必须会做这些事”）
	•	抽象类：定义能力 + 提供通用实现
	•	子类：落实这些能力 + 自己的特色

普通的父类子类他们就是共性和延伸的关系 
但是在抽象类里面的父类子类，父类是作为一个接口+部分实现的存在 而子类就是具体落实的存在

练习：（抽象类+子类+实现 打印动物名+动作）
1.子类的override
2.想要打印动物名 必须要在类中传入参数
练习1:（同上）
1.关于为什么动物名字字段要在父类里，因为：
  • 父类 Animal = “动物的身份证模版”（都得有名字）。
	•	子类 Dog / Cat = “具体的动物”，继承身份证模版，再加上自己的特点（会叫的方式）。
	•	如果没有在父类里规定“名字”，那每个子类都得自己发明身份证，既麻烦又容易不统一

  • 放在父类：因为 name 是所有动物的共性 → 统一管理，方便复用。
	•	放在子类：会造成重复代码，父类也无法使用 name，设计上不合理。
练习2:（交通工具car/plane）
1.唯一需要注意的点就是：
首先名字字段在父类中protected String name；（首先给出数据类型+数据名字）
然后给出方法public Transport（String name){this.name = name;}
然后在子类当中public Car(String name){super(name);}
注意厘清以上格式




10.2
抽象再次巩固练习
练习有感：
1.抽象方法只声明 -> 意味着 普通方法必须有方法题{}
2.子类只需要重写父类当中的抽象方法，普通方法不用
3.重写Override是 
1️⃣告诉编译器：这是重写父类的方法
如果没加 @Override，它就不会报错，而是当成一个新方法了。结果你以为自己重写了，其实没成功。（plus：错误的，override不必要，编译器自己知道你已经重写了）
2️⃣让代码更清晰：一眼就能看出这个方法是重写父类的，而不是子类自己新写的。（不必要）

🆕知识点：数组
1. 什么是数组？
•数组 (Array) 就是一组相同类型的数据，用一个名字存放在一起。
•你可以通过下标 (index) 来访问数组中的每一个元素。
•下标从 0 开始。
int[] numbers = {1,2,3,4,5};
for(int a: numbers){}





10.3
接口中所有都是抽象方法，不可以有正常方法
接口中所有方法都是public
所以这种情况下的public abstract是已经默认、可以省略的

public interface 接口名 这里的interface是声明他已经不是类，但是跟类很像
接口靠类实现
能继承接口的只能是接口，接口和类只能是实现关系implements
单继承，多实现
接口中所有变量都是全局静态常量（也就是final 不能重新赋值）

那么问题来了，一个实现接口的类和一个实现抽象类的子类是完全等同的吗？
不是：	
1.	继承方式不同
	•	类只能继承一个抽象类（单继承）。
	•	类可以实现多个接口（多实现）。⚠️（是对于类来讲 单继承：只能继承一个 多实现：能实现多个）
2.	内容不同
	•	抽象类可以有：构造器、普通方法、字段。
	•	接口早期只能有：抽象方法。
	•	Java 8+ 接口可以有 default 方法（带实现）、static 方法。
3.	设计目的不同
	•	抽象类 = 表达“是一种（is-a）”关系。
（例：Dog extends Animal → 狗是一种动物）
	•	接口 = 表达“能做什么（can-do）”关系。
（例：Dog implements Runnable → 狗能跑）

1.对比理解
你可以这样类比：
	•	抽象类 → 模板：规定“家族共性”，但不完整，子类要补全。
	•	接口 → 契约：规定“功能规范”，实现类要签合同，承诺“我要实现这些功能”。

	•	实现接口的类 可以同时实现多个接口，而继承抽象类只能一个。
	•	接口里方法的“抽象”更纯粹（早期没有任何实现），抽象类则是“抽象+部分实现”的混合体。



那：关于父类子类和接口的鉴别

1. 普通类（Concrete Class）
	•	可以有 普通方法（有实现的）。
	•	也可以继承自抽象类或实现接口，然后必须实现所有抽象方法。
	•	自己不能包含抽象方法。


2. 抽象类（Abstract Class）
	•	可以包含：
	•	抽象方法（没有方法体，子类必须实现）。
	•	普通方法（有实现，子类可以直接用或者重写）。
	•	子类：
    •	如果子类是普通类，必须实现所有继承的抽象方法。
	•	如果子类还是抽象类，可以选择不实现全部抽象方法。
（在什么样的情况下呢？）
1️⃣抽象类层层下放的情况下：Animal-Mammal-Elephent
2️⃣子类可能想要引入新的抽象概念
子类 B 继承抽象类 A，但它除了继承到的抽象方法之外，还想定义新的抽象方法，给下一级子类实现。
这样 B 就必须继续保持抽象。
3️⃣代码的设计意图更清晰
•	抽象类 Animal = 动物（会叫，会吃）
•	抽象类 Bird = 鸟（会飞，但飞的方式不确定）
•	具体类 Sparrow = 麻雀（具体实现会飞，会叫）
如果 Bird 一定要立刻实现所有 Animal 的抽象方法，那就没办法让“鸟类”这个层级保持抽象性了。
4️⃣重复抽象并不是浪费
“两个抽象类”并不是重复，而是分层次表达不同层面的抽象：
•	上层抽象类（比如 Animal）→ 定义最通用的抽象概念。
•	下层抽象类（比如 Mammal, Bird）→ 在上层抽象的基础上，继续约束更具体的共性。
•	最后由具体类实现所有抽象方法。
✅ 总结一句话：
子类继续是抽象类的意义在于——延续或扩展抽象责任，不是重复，而是分层次地建模，让代码结构更清晰。

	


4. 接口（Interface）
在 Java 不同版本中有一些演变：
	•	Java 8 之前：接口里只能有 public abstract 方法（抽象方法）。
	•	Java 8 开始：接口还可以有
	•	default 方法（有方法体，可以直接用或被重写）。
	•	static 方法。
	•	Java 9 开始：接口里甚至可以有 private 方法（主要是给 default 方法内部调用用的）。

所以接口并不是 “只能有抽象方法” 这么简单。






需复习：向上转型




10.4
1️⃣成员变量初始值：
java中所有变量必须先声明，后赋值才能使用；
java中的成员变量在创建对象时，都会执行一次初始化操作，都会给一个默认值
看各个数据类型的默认值：
byte/short/int/long = 0；
float/double = 0.0;
boolean = false;
char = 空；
string = null;
整型都是0
浮点是0.0
字符型都是/u0000

基本数据类型默认值都是0 包括boolean -> false
引用数据类型：null
null表示空，什么都没有，占位



2️⃣Object：





3️⃣equals和==：
==判断左右端的数据是否一致
equals是object类提供的一个方法，来判断两个对象是否相等

1.两个对象各个属性完全相同，用==判断 -> false
原因：默认判断的是两个对象的内存地址是否一致，也就是这两个对象是否是同一个
然后一般用==是判断基本数据类型，很少判断两个对象是否一致

2.那他俩啥区别？
默认情况下他俩相同，但equals就是可以个性化定制，你对父类object中默认判断内存地址的equals方法不满意，你就可以重写，比如根据小猫的颜色，小猫的体重等等来定制你想要的方法

3.例外情况：String
java中如果出现两个String是相同字符，并不会重复占用，第二次的String并没有单独占用空间，只会占用第一次出现的内存空间，所以这种情况下判断是true
equals在String数据类型下判断的是字符串是否相等！！
如果字符串直接赋值，那内存地址相同，==是true；如果字符串给他new了个新内存地址，那内存地址不同，==是false
对于字符串来说，更多用equals，一般是想判断内容是否一致，很少判断内存地址是否相同






10.7
toString：包名+类名+@内存地址

创建对象 直接打印System.o.pln(c)对象默认的是执行这个对象的toString[System.o.pln(c.toString)]，也就是这个对象用字符串表示应该是怎么样的


10.8
1️⃣instanceof：判断xx对象是否是xx类型的
意思是 如果xx对象是xx类型的一个实例
判断的时候就通过if...else语句来
if（ani instanceof Cat）{
  System.out.println("ani是小猫")；
}else{
  System.out.println("ani不是小猫")；
}
2️⃣参数传递的问题
java使用的是值传递；！！！理解这句话很重要

例1:
public static void change(int b) {
        b = 20;
        System.out.println(b);///b = 20⚠️
    }
    public static void main(String[] args){
        int a = 10;
        change(a);
        System.out.println(a);///a = 10
    }
	
例2:
public static void change(Cat c){
        c = new Cat("火猫");
        System.out.println(c.name);///火猫
    }
public static void main(String[] args){
        Cat c = new Cat("蓝猫");
        change(c);
        System.out.println(c.name);///蓝猫⚠️
    }

例3:
public static void change(Cat c){
        c.name = "土猫";
    }
public static void main(String[] args){
        Cat c = new Cat("蓝猫");
        change(c);
        System.out.println(c.name);///土猫⚠️❓为什么呢？
    }
本质上是看是new了一个新的内存地址出来还是在原有的地址上进行改动，前面都是new了新的地址，最后打印的都是原有地址内容；
例3是在原有的地址上进行改动，所以打印出来的是土猫。


理解完所有⚠️就完全没问题



3️⃣内存总体结构（栈、堆、方法区...）
在分析内存的时候主要是栈和堆，记住这两个的作用就好

区域                                          作用                                  举例
栈（Stack）                                   存放局部变量、方法调用信息                 int x = 5;、方法参数等
堆（Heap）                                    存放对象（Object），由 new 创建           new Cat("Mimi")
方法区 / 元空间（Method Area / Metaspace）      存放类信息、常量池、静态变量、方法字节码       类的定义、static 变量
程序计数器（PC寄存器）             				 记录当前线程执行到哪一行指令				   JVM内部使用
本地方法栈（Native Stack）						 用于Java调用C/C++等本地代码时			   很少手动接触

















