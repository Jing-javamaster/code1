Recap 1 10ğŸˆ·ï¸20æ—¥


/ é™¤æ³•è¿ç®— è®¡ç®—å•†      7 / 3 = 2ï¼ˆæ•´æ•°é™¤æ³•ï¼‰æˆ– 2.333...ï¼ˆæµ®ç‚¹é™¤æ³•ï¼‰
% å–ä½™è¿ç®— è®¡ç®—ä½™æ•°    7 % 3 = 1

codeè®¢æ­£
1ï¸âƒ£korrekte Deklaration & Initialisierung
boolean l1keTearsInTheRain;âœ…(åªä½œä¸ºå£°æ˜çš„è¯)

2ï¸âƒ£korrekte Initialisierung
boolean d;âŒå› ä¸ºå¸ƒå°”å€¼æ˜¯å±€éƒ¨å˜é‡ï¼ˆåœ¨æ–¹æ³•ã€if å—ã€for å—ã€while å—ç­‰é‡Œé¢å®šä¹‰çš„å˜é‡ï¼‰ã€‚æ‰€æœ‰å±€éƒ¨å˜é‡åœ¨ä½¿ç”¨å‰éƒ½å¿…é¡»æ˜¾å¼èµ‹å€¼
char e = "e";âŒ å¯¹äºcharæ˜¯'' ->char e = 'e';

float b = 5;âœ…ï¼ˆint->floatæ˜¯å…è®¸çš„ï¼Œä¼šè‡ªåŠ¨ç±»å‹æå‡ï¼‰
float c = 5.0f;âœ…
Integer g = new Integer(5);âœ…

3ï¸âƒ£
Integer a = new Integer(4);
Integer b = a;
a = new Integer(5);
// Welchen Wert hat b?
é€‰é¡¹ï¼š
Objekt von Typ Integer mit dem Wert 5
Es gibt einen Fehler
null
5
Objekt von Typ Integer mit dem Wert 4âœ…
4

4ï¸âƒ£
int a = (5 + 2) / 2;        a=3
float b = (3 + 4) / 3;      b=7/3
int c = (int) ((a + b) % 42);  ///å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼ˆtype castï¼‰åªä¿ç•™intéƒ¨åˆ†


5ï¸âƒ£printå’Œprintlnçš„åŒºåˆ«ï¼šæœ‰æ²¡æœ‰æ¢è¡Œ

System.out.print("Hello");
System.out.print("World"); â€”â€”â€”â€”>HelloWorld

System.out.println("Hello");
System.out.println("World");â€”â€”â€”â€”>Hello
                                 World

6ï¸âƒ£
Wie kann man den Wert der Variablen a in die Konsole ausgeben, wenn sie ein Objekt ist?
System.out.print(a.value);
System.out.println(a);
System.out.print(a.val);
Keine der oben genannten Optionenâœ…
System.out.print(a);
è§£ç­”ï¼š
åœ¨ Java ä¸­ï¼Œå¯¹è±¡å˜é‡ä¿å­˜çš„ä¸æ˜¯â€œå€¼â€ï¼Œè€Œæ˜¯â€œå¼•ç”¨â€ï¼ˆå³å†…å­˜åœ°å€ï¼‰ã€‚
æ­¤æ—¶ï¼ŒJava ä¼šè°ƒç”¨ a.toString() æ–¹æ³•ã€‚è€Œé»˜è®¤çš„ toString() è¾“å‡ºæ˜¯ï¼šç±»å@å“ˆå¸Œç 
æ‰€ä»¥ä¸ºäº†è¾“å‡ºçœŸæ­£çš„å€¼ï¼š1.ç±»è‡ªå·±è¦†ç›–ï¼ˆoverrideï¼‰äº† toString() æ–¹æ³•ï¼› 2.é€šè¿‡ Getter æ–¹æ³•è®¿é—®å­—æ®µâ“
1.ç±»è‡ªå·±è¦†ç›–ï¼ˆoverrideï¼‰äº† toString() æ–¹æ³• æ„æ€å°±æ˜¯åœ¨å½“å‰è¿™ä¸ªç±»å½“ä¸­ï¼Œæˆ‘ä»¬é‡å†™toStringè¿™ä¸ªæ–¹æ³•åˆ°æˆ‘ä»¬éœ€è¦çš„å€¼ï¼Œæˆ–è€…åƒè¿™é‡Œä¾‹å­é‡Œçš„åå­—ï¼Œç„¶åå†ç›´æ¥æ‰“å°éœ€è¦çš„å˜é‡ï¼Œå°±æ˜¯æˆ‘ä»¬éœ€è¦çš„å€¼


7ï¸âƒ£Welche Variablen sind an der markierten Stelle im folgenden Code sichtbar?
public void testMethod(int a) {
    int b = 0;
    if (b > 0) {
        int c = 2;
    }
    // Welche Variablen sind hier sichtbar? Loesung:a,b
    int d = 1;
}
	â€¢  aï¼ˆæ–¹æ³•å‚æ•°ï¼‰ï¼šæ•´ä¸ªæ–¹æ³•ä½“å†…å¯è§ â†’ åœ¨æ ‡è®°å¤„å¯è§ã€‚
	â€¢  bï¼ˆåœ¨æ–¹æ³•ä½“å†…å£°æ˜ï¼‰ï¼šä»å£°æ˜å¤„å¼€å§‹åˆ°æ–¹æ³•ç»“æŸ â†’ åœ¨æ ‡è®°å¤„å¯è§ã€‚


8ï¸âƒ£ç¬¬15é¢˜â€¼ï¸
å®é™…ä¸Šè€ƒæŸ¥çš„æ˜¯ åœ¨printlnçš„ä½œç”¨åŸŸå†…æœ‰å“ªäº›å˜é‡
è¿™é‡Œå¼•ç”³äº†ä¸€ä¸ª{}çš„çŸ¥è¯†ç‚¹ï¼Œæœ‰æ—¶å€™æ— ä¸­ç”Ÿæœ‰çš„èŠ±æ‹¬å·å…¶å®æ˜¯åœˆåœ°è‡ªåœ†ï¼Œå°±æ˜¯ä¸ºäº†éš”å¼€è¿™ç§ä½œç”¨åŸŸåœ¨æ•´ä¸ªæ–¹æ³•ä½“å†…çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è¯´é¢˜ç›®é‡Œçš„lå®ƒåªæ´»åœ¨èŠ±æ‹¬å·å†…

9ï¸âƒ£ç¬¬17é¢˜â€¼ï¸
a,b,cå®ƒä»¬å®šä¹‰åœ¨ç±»ä½“å†…ã€æ–¹æ³•å¤–ã€‚æ‰€ä»¥å®ƒä»¬çš„ä½œç”¨åŸŸæ˜¯ï¼šæ˜¯å±äºæ•´ä¸ªç±»çš„æ‰€æœ‰æ–¹æ³•ä¸­éƒ½å¯è®¿é—®ï¼ˆåŒä¸€ä¸ªå¯¹è±¡å®ä¾‹å†…ï¼‰ã€‚

é‡ç‚¹å…³æ³¨ï¼šåµŒå¥—å—çš„ä½œç”¨åŸŸ



Recap2 10ğŸˆ·ï¸27æ—¥

1.do-whileè¯­å¥ do{schleifenrumpf} while(æ¡ä»¶); å› æ­¤å¾ªåè‡³å°‘æ‰§è¡Œä¸€æ¬¡ï¼Œå› ä¸ºæ£€æŸ¥æ¡ä»¶åœ¨åé¢
2.å¾ªç¯è¯­å¥çš„è½¬åŒ–
(1)forè¯­å¥åŠå…¶ä»–è¯­å¥çš„è½¬åŒ–
for(int i = 0; i < 5; i++){
// deinen Code hier
}

int i = 0;
while(i < 5){
// deinen Code hier
i++;
}

int i = 0;
do {
if(i > -1){
// deinen Code hier
}
i++;
}
while(i < 5);

(2)whileè¯­å¥åŠå…¶ä»–è¯­å¥çš„è½¬åŒ–
while(bedingung){
// deinen Code

for (; bedingung;){
// deinen Code
}

do{
 if(bedingung){
 // deinen Code
 }
}
while(bedingung);


3.breakå’Œcontinueçš„åŒºåˆ«
å…³é”®å­—		ä½œç”¨å¯¹è±¡			æ‰§è¡Œæ•ˆæœ
break		æ•´ä¸ªå¾ªç¯			ç«‹å³ç»ˆæ­¢æ•´ä¸ªå¾ªç¯ï¼ˆè·³å‡ºå¾ªç¯ä½“ï¼‰
continue	å½“å‰å¾ªç¯çš„ä¸€æ¬¡è¿­ä»£	ç«‹å³è·³åˆ°ä¸‹ä¸€æ¬¡å¾ªç¯ï¼ˆè·³è¿‡å½“å‰è¿­ä»£ä¸­å‰©ä½™çš„è¯­å¥ï¼‰


4.forå¾ªç¯è¯­å¥çš„ç»“æ„
for(Initialisierung;Bedingung;Inkrement)


theorieè®¢æ­£
1ï¸âƒ£ä½¿ç”¨forå¾ªç¯è¯­å¥çš„æ¡ä»¶ï¼šçŸ¥é“æ¬¡æ•°
ä½¿ç”¨whileå¾ªç¯è¯­å¥çš„æ¡ä»¶ï¼šä¸çŸ¥é“æ¬¡æ•°

2ï¸âƒ£forå¾ªç¯è¯­å¥Kopfæ„é€ (Initialisierung;Bedingung;Aktualisierungâ€¼ï¸)

3ï¸âƒ£continueä¸èƒ½åœ¨Schleifenrumpfä»¥å¤–ä½¿ç”¨ï¼Œæ˜¯è¯­ä¹‰é”™è¯¯

4ï¸âƒ£breakçš„ä½œç”¨ï¼šBeendet die gesamte Schleife vollstÃ¤ndig
âš ï¸ä¸æ˜¯Ãœberspringt den Rest des Schleifenrumpfs(åªæ˜¯è·³è¿‡å½“å‰Iterationçš„å‰©ä½™éƒ¨åˆ†)
continueçš„ä½œç”¨ï¼šÃœberspringt den Rest des Schleifenrumpfs und geht zur nÃ¤chsten Iteration

5ï¸âƒ£continueå’Œbreakåªè¦åœ¨å¾ªç¯rumpfé‡Œé¢å°±å¯ä»¥ï¼Œä¸é™å®šå¾ªç¯è¯­å¥ç±»å‹

6ï¸âƒ£forå¾ªç¯è¯­å¥çš„å¤´éƒ¨ä¸‰éƒ¨åˆ†å“ªä¸€éƒ¨åˆ†æ˜¯å¯ä»¥èˆå¼ƒçš„ï¼ŸAï¼šå…¨éƒ¨
for( ; ; ){
    // Endlosschleife !!!
}
7ï¸âƒ£åœ¨ä¸€ä¸ªå¾ªç¯çš„å¤´éƒ¨æ¡ä»¶ä¸€ç›´æ˜¯trueï¼Œé‚£å°±ä¼šä¸€ç›´æ‰§è¡Œï¼Œç›´åˆ°æ‰‹åŠ¨breakæˆ–è€…æŠ¥é”™

8ï¸âƒ£è®¡ç®—åµŒå¥—å¾ªç¯çš„æ¬¡æ•°ï¼šæ ¹æ®å†…å±‚å¾ªç¯åœ¨æ¯æ¬¡å¤–å±‚è¿­ä»£çš„æ—¶å€™ï¼Œå¾ªç¯çš„æ¬¡æ•°æ˜¯å¦éƒ½ç›¸åŒæ¥åˆ¤æ–­ï¼Œå¦‚æœç›¸åŒé‚£å°±å¯ä»¥å†…å¤–ä¸¤å±‚çš„å¾ªç¯æ¬¡æ•°ç›¸ä¹˜ç­‰äºæ€»å¾ªç¯æ¬¡æ•°ï¼Œå¦‚æœä¸åŒçš„è¯ï¼Œé‚£è®¡ç®—æ€»å¾ªç¯æ¬¡æ•°å°±è¦ä½¿ç”¨åŠ æ³•

9ï¸âƒ£âŒDie innere Schleife wird parallel zur Ã¤uÃŸeren ausgefÃ¼hrt, was die Parallelisierung des Codes erleichtert
å¾ªç¯çš„æœ¬è´¨æ˜¯é¡ºåºæ‰§è¡Œï¼Œå¹¶ä¸æ˜¯å¹¶è¡Œæ‰§è¡Œ



codeè®¢æ­£
1ï¸âƒ£
int i = 0;
while(i < 5){
    int sum = i;
    i++;
}
âœ…Sie durchlÃ¤uft die Zahlen von 0 bis 5 und speichert den aktuellen Wert in der Variablen i

2ï¸âƒ£int j = 1;
do {
    int i = 1;
    i = 5 + j;
    j *= 2;
}
while(i < 2);
âœ…Keine, da ein Kompilierungsfehler enthalten istâ€¼ï¸ğŸ¤”
å› ä¸ºiåœ¨èŠ±æ‹¬å·å½“ä¸­ï¼Œå‡ºäº†èŠ±æ‹¬å·iå°±ä¸å­˜åœ¨ï¼Œæ‰€ä»¥æ— æ³•åœ¨whileå½“ä¸­æ£€æŸ¥içš„æ¡ä»¶

3ï¸âƒ£ä»£ç Ã„quivalenzåˆ¤æ–­æ ‡å‡†ï¼š
å¦‚æœä¸¤æ®µå¾ªç¯äº§ç”Ÿçš„è¾“å‡ºå…¨ç›¸åŒï¼Œé‚£ä¹ˆå®ƒä»¬è¢«è§†ä¸ºç­‰ä»·ï¼ˆÃ¤quivalentï¼‰ã€‚

4ï¸âƒ£System.out.println()ï¼š
æ‰“å°ä¸€ä¸ªæ¢è¡Œç¬¦ï¼ˆnewlineï¼‰ï¼Œä¸æ‰“å°ä»»ä½•å…¶å®ƒå­—ç¬¦ã€‚
==>è¡¨ç¤ºæ¢åˆ°ä¸‹ä¸€è¡Œ

5ï¸âƒ£0 % 2 == ï¼Ÿ
ç­”æ¡ˆç­‰äº0
å› ä¸ºä½™æ•°æ°¸è¿œå°äºé™¤æ•°ï¼ˆ2ï¼‰ã€‚







Recap3 11ğŸˆ·ï¸3æ—¥

1.Arrayså›ºå®šçš„speicherplatzï¼Œå¤§å°ä¸èƒ½æ”¹å˜
int a[] = {1,2,3,4,5}
å¯¹äºç®€å•æ•°æ®ç»“æ„ï¼šåªèƒ½æ˜¯å’Œè‡ªå·±arrayåŒç±»å‹çš„æ•°æ®
å¤æ‚ç±»å‹arrayï¼šåŒç±»å‹&å­ç±»çš„ç±»å‹ï¼ˆæ¯”å¦‚numberçš„å­ç±»æ˜¯integerå’Œfloatï¼‰

2.ä¸ºä»€ä¹ˆä½¿ç”¨arraysï¼Ÿ
åœ¨åŒä¸€ä¸ªåå­—ä¸‹å­˜å‚¨å¤šä¸ªæ•°æ®ï¼›é€šè¿‡indexè·å–ï¼›é€‚ç”¨äºå¾ªç¯å’Œæ‰¹é‡å¤„ç†

3.Arrayçš„å£°æ˜
Typ[] nameDerVariable = new Typ[ LÃ¤ngeAlsGanzzahl ];

4.åœ¨arrayåªå£°æ˜ï¼Œä¸åˆå§‹åŒ–æ—¶ï¼š
Integer[] a;æ­¤æ—¶è¿™ä¸ªarrayä¸å­˜åœ¨ï¼Œä¼šç¼–è¯‘é”™è¯¯â€¼ï¸åœ¨ Java ä¸­ï¼Œnew int[] è¿™ä¸ªå†™æ³•å¿…é¡»è¦ä¹ˆæŒ‡å®šé•¿åº¦ï¼Œè¦ä¹ˆç«‹åˆ»ç»™å‡ºåˆå§‹åŒ–åˆ—è¡¨ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šä¸çŸ¥é“è¦åˆ†é…å¤šå¤§çš„ç©ºé—´ã€‚
å¦‚æœä½ è¦ç»™å…¶ä¸­ä¸€ä¸ªä½ç½®åˆå§‹åŒ–a[0] = 4; -> ä¼šæŠ¥é”™
æ­¤æ—¶ä¹Ÿä¸èƒ½è°ƒç”¨å’Œè¿™ä¸ªarrayå±æ€§ç›¸å…³çš„a.length ä¼šæŠ›å‡ºNullPointerException

5.åªç”¨æ ‡å‡†å€¼åˆå§‹åŒ–æ—¶ï¼ˆåªåˆ›å»ºäº†arrayä¸”å†™äº†é•¿åº¦ï¼‰ï¼š
int[] a = new int [5]; æ­¤æ—¶æ¯ä¸ªä½ç½®éƒ½æ˜¯0ï¼ˆboolean-false; float-0.0fï¼‰â€¼ï¸
â€¼ï¸æ— æ³•è°ƒç”¨a[i].method()/a.attribute  ->  ä¼šæŠ›å‡ºNullPointerException
âœ…ä½†æ˜¯æ˜¯åˆæ³•çš„ï¼Œåªæ˜¯æ— æ³•è°ƒç”¨ç©ºæ•°ç»„çš„å‚æ•°å’Œæ–¹æ³•

6.å¡«å……arrayçš„å…ƒç´ ï¼š
int[] zahlen = new int[5];
for (int i = 0; i < zahlen.length; i=+) {
	System.out.println(zahlen[i]);
}
Alternativï¼š
for (int zahl : zahlen) {
	System.out.println(zahl);
}
â€¼ï¸for (Type elementName : arrayName){
	System.out.println(elementName);//è‡ªå·±å–çš„elementName
}


7.å¤šç»´arraysï¼ˆäºŒä½æ•°ç»„ä¸­çš„ç»“æ„å½¢å¼ï¼‰
rechteckigçŸ©å½¢çŠ¶ï¼šint[][] a = new int[2][9] (çŸ©å½¢2x9)
jaggedé”¯é½¿çŠ¶ï¼š
int[][] b= new int[2][];///åªç¡®è®¤å¤–å±‚å…ƒç´ 
b[0] = new int[4];///ç¬¬ä¸€è¡Œ4ä¸ªå…ƒç´ ï¼šå†…å±‚å…ƒç´ ç¡®è®¤
b[1] = new int[2];///ç¬¬äºŒè¡Œ2ä¸ªå…ƒç´ 


8.arrayså¸¸è§çš„æŠ¥é”™ï¼š
ArrayIndexOutOfBoundsExceptionï¼šindexåœ¨æœ‰æ•ˆè¾¹ç•Œå¤–ï¼ˆä¸€èˆ¬å‘ç”Ÿåœ¨ï¼šå¾ªç¯è¾¹ç•Œé”™è¯¯ï¼‰
NullPointerExceptionï¼šè°ƒç”¨äº†æœªåˆå§‹åŒ–çš„arrayæˆ–è€…å…ƒç´ ï¼ˆåªå£°æ˜äº†ï¼Œä½†æ˜¯æœªåˆå§‹åŒ–ï¼Œå³ä½¿å£°æ˜äº†é•¿åº¦ï¼‰
é”™å°†lengthå†™æˆlength();
ä¸ç›¸å®¹çš„å…ƒç´ ç±»å‹:å£°æ˜çš„æ•°ç»„ç±»å‹ä¸å…ƒç´ ç±»å‹ä¸ç¬¦ï¼›
arraysçš„æ‰“å°æ–¹æ³•ï¼š
1ï¸âƒ£
int[][] matrix = {{1, 2}, {3, 4}};
for (int i = 0; i < matrix.length; i++) {
	for (int j = 0; j < matrix[i][j].length; j++) {
    	System.out.print(matrix[i] + " ");
	}
    System.out.println();/////è¿™æ˜¯æ¢è¡Œ
}
è¾“å‡ºï¼š
1 2 
3 4 
2ï¸âƒ£Arrays.toString(a);è¿™æ˜¯ç³»ç»Ÿè‡ªåŠ¨æ‰“å°ï¼ï¼ï¼ï¼åªè¾“å‡ºä¸€è¡Œä¸”æ— æ³•æ§åˆ¶è¾“å‡ºæ ¼å¼
æ¯”å¦‚ä¸€ç»´æ•°ç»„ï¼šâ€¼ï¸int[] a = {1, 2, 3};System.out.println(Arrays.toString(a));
å¤šä½æ•°ç»„ï¼šint[][] b = { {1, 2}, {3, 4} };
System.out.println(Arrays.deepToString(b));â€¼ï¸deepTo Tä¹Ÿè¦å¤§å†™




9.ä¸€ç»´å’ŒäºŒç»´çš„æ•°ç»„ç¤ºä¾‹
// Eindimensionales Array (Kurzschreibweise)
int[] numbers = {1, 2, 3};
int[] zahlen = new int[3];
zahlen[0] = 1;
zahlen[1] = 2;
zahlen[2] = 3;
// Zweidimensionales Array (Kurzschreibweise)
int[][] matrix = {
{1, 2, 3},
{4, 5, 6},
{7, 8, 9}
};


10.å°ä½œä¸šâœï¸
1ï¸âƒ£Array-Inhalt ausgeben (for-each) 
2ï¸âƒ£Summe aller Elemente berechnen
3ï¸âƒ£äºŒç»´æ•°ç»„è¿­ä»£




theorieè®¢æ­£
1ï¸âƒ£Arrays in Javaï¼šEs ist eine Datenstruktur, in der Elemente desselben Typs gespeichert werden.
Java è§„å®šï¼š
æ•°ç»„çš„æ‰€æœ‰å…ƒç´ éƒ½å¿…é¡»æ˜¯ç›¸åŒçš„ç¼–è¯‘æ—¶ç±»å‹ï¼ˆcompile-time typeï¼‰ã€‚
è¿™å¥è¯çš„å…³é”®æ˜¯â€”â€”â€œç¼–è¯‘æ—¶çœ‹æ¥æ˜¯åŒä¸€ç±»å‹â€ï¼Œ
ä½†â€œè¿è¡Œæ—¶å®é™…å­˜çš„å¯¹è±¡â€å¯ä»¥æ˜¯è¿™ä¸ªç±»å‹çš„å­ç±»å®ä¾‹ã€‚

2ï¸âƒ£åœ¨ Java é‡Œå¯ä»¥åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º 0 çš„æ•°ç»„âœ…
Java ä¸­æ•°ç»„çš„åˆ›å»ºè¯­æ³•ï¼šTyp[] name = new Typ[ganze positive Zahl];
å› ä¸º 0 ä¹Ÿæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ä¸ä¼šæŠ¥é”™ï¼Œè¿è¡Œä¹Ÿæ­£å¸¸ã€‚
âš ï¸åªæ˜¯é•¿åº¦ä¸º0çš„æ•°ç»„ä¸èƒ½è°ƒç”¨è¿™ä¸ªæ•°ç»„çš„å‚æ•°å’Œæ–¹æ³•


3ï¸âƒ£ä¸¤ä¸ªæ•°ç»„çš„ç›¸ç­‰æ€§èƒ½é€šè¿‡==æ¥æ¯”è¾ƒâŒâ€¼ï¸å¼•ç”¨ç±»å‹å’ŒåŸºæœ¬ç±»å‹çš„åŒºåˆ«
1.æ•°ç»„æ˜¯å¼•ç”¨ç±»å‹ï¼Œç”¨ == æ¯”è¾ƒå¼•ç”¨ç±»å‹æ—¶ï¼Œæ¯”è¾ƒçš„ä¸æ˜¯å†…å®¹ï¼Œè€Œæ˜¯åœ°å€ï¼ˆReferenz/IdentitÃ¤tï¼‰
â€¼ï¸å› ä¸º == æ¯”è¾ƒçš„æ˜¯ï¼šâ€œä¸¤ä¸ªå˜é‡æ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼ˆåŒä¸€ä¸ª Speicheradresseï¼‰â€ã€‚
å¦‚æœæƒ³è¦æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„å†…å®¹æ˜¯å¦ç›¸ç­‰ï¼ŒSystem.out.println(Arrays.equals(a, b)); // æ¯”è¾ƒaã€bä¸¤ä¸ªæ•°ç»„
ï¼ˆå¤šä½æ•°ç»„ï¼‰System.out.println(Arrays.deepEquals(a, b));


å¼•ç”¨ç±»å‹ï¼ˆReference Typeï¼‰ æ˜¯ä¸€ç§å˜é‡ï¼Œå®ƒä¸ç›´æ¥å­˜å‚¨æ•°æ®æœ¬èº«ï¼Œè€Œæ˜¯å­˜å‚¨æ•°æ®åœ¨å†…å­˜ä¸­çš„åœ°å€ï¼ˆå¼•ç”¨ï¼‰ã€‚

ç±»å‹ç±»åˆ«							ä¸¾ä¾‹															å­˜çš„æ˜¯ä»€ä¹ˆ				å­˜åœ¨å“ªé‡Œ
åŸºæœ¬ç±»å‹ (Primitive Types)		int, double, boolean, char, â€¦								ç›´æ¥å­˜å‚¨å€¼æœ¬èº«				æ ˆ (Stack)
å¼•ç”¨ç±»å‹ (Reference Types)		String, æ•°ç»„ (int[], String[]), å¯¹è±¡ (Person, Scanner)		å­˜çš„æ˜¯å¯¹è±¡åœ¨å †é‡Œçš„åœ°å€		æ ˆä¸Šå­˜å¼•ç”¨ï¼Œå †ä¸Šå­˜å¯¹è±¡

æ¯”å¦‚è¯´ï¼š
åŸºæœ¬ç±»å‹int a = 5ï¼›  -> a é‡ŒçœŸçš„å°±æ˜¯æ•°å­— 5
å¼•ç”¨ç±»å‹åƒæ˜¯ä¸€ä¸ªâ€œä¿¡ç®±å·â€ï¼Œé‡Œé¢è£…çš„æ˜¯åœ°å€ï¼šString s = "Hello";
s å˜é‡é‡Œå­˜çš„ä¸æ˜¯ â€œHelloâ€ï¼Œè€Œæ˜¯â€œHelloâ€ åœ¨å†…å­˜ä¸­é‚£å—åŒºåŸŸçš„åœ°å€ï¼ˆå¼•ç”¨ï¼‰ã€‚



4ï¸âƒ£æ•°ç»„çš„ä¼˜ç‚¹ï¼šEinfache und schnelle ZugriffsmÃ¶glichkeiten Ã¼ber Indizesâœ…

Sie speichern Daten dauerhaft auf der FestplatteâŒæ•°ç»„æ˜¯å†…å­˜ï¼ˆRAMï¼‰é‡Œçš„ä¸´æ—¶æ•°æ®ç»“æ„ã€‚ç¨‹åºç»“æŸåæ•°ç»„æ¶ˆå¤±ï¼Œé™¤éä½ æ˜¾å¼åœ°æŠŠå†…å®¹å†™è¿›æ–‡ä»¶ï¼ˆé‚£æ˜¯ IO æ“ä½œï¼Œä¸æ˜¯æ•°ç»„çš„åŠŸèƒ½ï¼‰ã€‚


5ï¸âƒ£Was passiert, wenn man versucht, auf ein Element auÃŸerhalb des gÃ¼ltigen Indexbereichs zuzugreifen?
Es wird eine Exception zur Laufzeit ausgelÃ¶stï¼ˆç¨‹åºè¿è¡Œæ—¶ä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼‰âœ…

Das Programm wird kompiliert, aber mit WarnungâŒ
â€œç¼–è¯‘é€šè¿‡â€ å°±æ˜¯è¯´ â€”â€” è¿™æ®µä»£ç åœ¨è¯­æ³•ä¸Šåˆæ³•ï¼Œç¼–è¯‘å™¨èƒ½æŠŠå®ƒç¿»è¯‘æˆå¯æ‰§è¡Œçš„å­—èŠ‚ç ã€‚
å®ƒä¸ä¼šæŠ¥â€œSyntax Errorâ€ï¼Œä½†ä¸ä»£è¡¨ç¨‹åºè¿è¡Œæ—¶ä¸ä¼šå‡ºé”™ã€‚



Codefragen
1ï¸âƒ£æ•°ç»„å£°æ˜ï¼šå¿…é¡»è¦ä¹ˆæŒ‡å®šé•¿åº¦ï¼Œè¦ä¹ˆç«‹åˆ»ç»™å‡ºåˆå§‹åŒ–åˆ—è¡¨ã€‚ ï½œ
å¦åˆ™ç¼–è¯‘å™¨ä¼šä¸çŸ¥é“è¦åˆ†é…å¤šå¤§çš„ç©ºé—´ï¼Œcompileré”™è¯¯	    ï½œ
â€¼ï¸ä½†æ˜¯æ•°ç»„å¯ä»¥åªå£°æ˜int[] a;åˆæ³•âœ…				ï½œ
ä½†æ˜¯ä¸èƒ½åŠåŠå­å£°æ˜int[] a = new int [];æ­¤æ—¶<â€”â€”â€”â€”â€”ï½œ

2ï¸âƒ£æ•°ç»„é•¿åº¦ä¸º0å¯ä»¥è®¿é—®lengthï¼Œåªæœ‰å½“æ²¡æœ‰ç»™å®šé•¿åº¦æ—¶-> NullPointerException

3ï¸âƒ£ä¸€ä¸ªæ•°ç»„åªç»™å®šäº†é•¿åº¦ï¼Œæ²¡æœ‰åˆå§‹åŒ–ï¼Œé‚£ä¹ˆæ­¤æ—¶æ‰“å°æŸä¸€ä¸ªå…ƒç´ å¯ä»¥å—ï¼Ÿçœ‹ç±»å‹åˆ†æƒ…å†µâ€¼ï¸
1.åŸºæœ¬ç±»å‹æ•°ç»„intï¼Œbooleanï¼Œfloat....å¯ä»¥
2.å¼•ç”¨ç±»å‹æ•°ç»„String.....å¯ä»¥æ‰“å°å…ƒç´ ä½†æ˜¯è¿è¡Œæ—¶æŠ› NullPointerExceptionâš ï¸


4ï¸âƒ£Ausgabeï¼Ÿ
int[] arr = new int[5];
arr[4] = 5;
System.out.println(arr[42 % arr.length]);
ç­”æ¡ˆï¼š0


5ï¸âƒ£Ausgabeï¼ŸğŸ¤”
int[] arr = new int[0];
for (int num : arr) {
    System.out.println(num);
}
ç­”æ¡ˆï¼šä»€ä¹ˆéƒ½æ²¡æœ‰
â€¼ï¸è¿™é‡Œä»£ç æœ¬è´¨ä¸Šç­‰äº
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    System.out.println(num);
}
æ‰€ä»¥å¾ªç¯æ¡ä»¶ i < arr.length ä¸€å¼€å§‹å°±ä¸º falseã€‚
å¾ªç¯ä½“æ ¹æœ¬ä¸ä¼šè¢«æ‰§è¡Œä¸€æ¬¡ã€‚
æ§åˆ¶å°ä»€ä¹ˆéƒ½ä¸ä¼šè¾“å‡ºã€‚


6ï¸âƒ£Ausgabeï¼Ÿ
int[] arr = {1, 2, 3};
for (int num : arr) {
    num = num * 2;
}
System.out.println(arr[0]);


for (int num : arr)è¿™å¥è¯ç­‰ä»·äºï¼š
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    num = num * 2;
}
ç­”æ¡ˆæ˜¯ï¼š1
å…³é”®ç‚¹ âš ï¸ï¼šnum åªæ˜¯ arr[i] çš„ä¸€ä¸ªå‰¯æœ¬ï¼ˆcopyï¼‰ã€‚ä¿®æ”¹ num ä¸ä¼šåè¿‡æ¥æ”¹å˜ arr[i]ã€‚
---> æ•°ç»„ arr å®Œå…¨æ²¡æœ‰è¢«ä¿®æ”¹ã€‚



7ï¸âƒ£Ausgabeï¼Ÿ
int[] arr = null;â“æˆ‘æƒ³é—®è¿™é‡Œç»™æ•°ç»„èµ‹å€¼nullæ˜¯ç­‰åŒäºå»ºç«‹äº†ä¸€ä¸ªé•¿åº¦ä¸º0çš„æ•°ç»„å—ï¼ŸAï¼šä¸€ä¸ªæ˜¯â€œä»€ä¹ˆéƒ½æ²¡æœ‰â€ï¼Œå¦ä¸€ä¸ªæ˜¯â€œæœ‰ä¸œè¥¿ï¼Œä½†é‡Œé¢ç©ºâ€ã€‚arr æŒ‡å‘ä¸€ä¸ªé•¿åº¦ä¸º 0 çš„æ•°ç»„å¯¹è±¡
for (int num : arr) {
    System.out.println(num);
}
ç­”æ¡ˆæ˜¯ï¼š NullPointerException



â€¼ï¸â€¼ï¸â€¼ï¸é¦–å…ˆè¦ç†è§£ï¼šå¢å¼ºå‹ for çš„æœ¬è´¨
å¢å¼º for å¾ªç¯å…¶å®æ˜¯ç¼–è¯‘å™¨å¸®ä½ è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç ï¼Œ
ç­‰ä»·äºï¼š
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    System.out.println(num);
}

åœ¨æ‰§è¡Œ for-each å‰ï¼ŒJava ä¼šå…ˆå»è°ƒç”¨ï¼š
arr.iterator()   // å¯¹é›†åˆ
arr.length       // å¯¹æ•°ç»„
ä½†æ˜¯arr æ˜¯ nullï¼Œæ‰€ä»¥ä¸€æ—¦è®¿é—® .lengthå°±ä¼šæŠ›å‡ºï¼šNullPointerException











Recap3 11ğŸˆ·ï¸10æ—¥
1.ç±»çš„ä½œç”¨ï¼šInformationå’ŒMethodeçš„Container
ç±»å®šä¹‰ï¼š
	å±æ€§ï¼šæè¿°å¯¹è±¡çš„çŠ¶æ€
	æ–¹æ³•ï¼šæè¿°å¯¹è±¡å¯ä»¥åšä»€ä¹ˆ

2.Konstruktoræ„é€ å™¨
ä½ å¯ä»¥åœ¨åŒä¸€ä¸ªç±»ä¸­å®šä¹‰å¤šä¸ªæ„é€ å‡½æ•°ï¼Œåªè¦å®ƒä»¬çš„å‚æ•°åˆ—è¡¨ä¸åŒå³å¯ã€‚
ä¹Ÿå°±æ˜¯æ„é€ å‡½æ•°å¯ä»¥è¢«é‡è½½ï¼ˆÃ¼berladenï¼‰ã€‚
ä¾‹å¦‚ï¼š
class Auto {
    Auto() {}                  // æ— å‚æ„é€ 
    Auto(String marke) {}      // ä¸€ä¸ª String å‚æ•°
    Auto(String marke, int bj) {} // ä¸¤ä¸ªå‚æ•°
}


3.æ„é€ æ–¹æ³•çš„æ—¶å€™ä½¿ç”¨thisæŠŠå‚æ•°èµ‹å€¼ç»™å±æ€§
ä¹Ÿå°±æ˜¯è¯´ å¦‚æœæˆ‘ä»¬åœ¨æ„é€ ä¸€ä¸ªæ–¹æ³•çš„æ—¶å€™ ä¼ è¿›æ¥çš„å‚æ•°åå’Œæˆ‘ä»¬éœ€è¦æ„é€ çš„å±æ€§åå­—ä¸€æ ·ï¼Œé‚£ä¹ˆæŠŠå‚æ•°èµ‹å€¼ç»™è¿™ä¸ªå±æ€§çš„æ—¶å€™ä½¿ç”¨thisï¼Œä¸åŒå°±ä¸ç”¨ä½¿ç”¨this
ä¾‹å¦‚ï¼š
public Student(String n, int matrikelnummer) {
    name = n;                        // â¶
    this.matrikelnummer = matrikelnummer;  // â·
}


4.thisçš„ä½œç”¨ï¼šå¯¹å½“å‰å¯¹è±¡çš„å¼•ç”¨
1ï¸âƒ£åœ¨å¯¹è±¡æ–¹æ³•å’Œæ„é€ å‡½æ•°ä¸­ä½¿ç”¨
2ï¸âƒ£æŒ‡å‘å½“å‰è¿è¡Œè¯¥æ–¹æ³•çš„å¯¹è±¡ã€‚
3ï¸âƒ£ç”¨äºåŒºåˆ†åŒåçš„å±æ€§å’Œå‚æ•°ã€‚
4ï¸âƒ£â€¼ï¸åœ¨é™æ€æ–¹æ³•ä¸­ä¸å…è®¸ï¼Œå› ä¸ºæ²¡æœ‰å¯¹å¯¹è±¡çš„å¼•ç”¨ï¼


5.staticçš„ä½œç”¨ï¼š
1ï¸âƒ£é™æ€å…ƒç´ ï¼ˆå±æ€§/æ–¹æ³•ï¼‰å±äºç±»ï¼Œè€Œä¸æ˜¯å•ä¸ªå¯¹è±¡ã€‚
2ï¸âƒ£æ‰€æœ‰å¯¹è±¡å…±äº«ç›¸åŒçš„é™æ€å±æ€§å€¼ï¼ˆå‚è§ç¬¬ 5ã€9 é¡µï¼‰ã€‚
3ï¸âƒ£é€šè¿‡ç±»åè€Œä¸æ˜¯é€šè¿‡å¯¹è±¡è°ƒç”¨ã€‚


6.finalçš„ä½œç”¨
1ï¸âƒ£æœ€ç»ˆå˜é‡ - Wert bleibt konstant
2ï¸âƒ£final method - ä¸èƒ½overrideé‡å†™
3ï¸âƒ£final class - ç±»ä¸èƒ½ç»§æ‰¿ï¼ˆæ‰©å±•ï¼‰


7.å…¶ä»–çš„è®¿é—®ä¿®é¥°ç¬¦
â€¼ï¸å›¾



8.ç»§æ‰¿ï¼šä¸€ä¸ªç±»å¯ä»¥æ‰©å±•ï¼ˆç»§æ‰¿ï¼‰å¦ä¸€ä¸ªç±»ã€‚
1ï¸âƒ£çˆ¶ç±»çš„æ‰€æœ‰æ–¹æ³•å’Œå±æ€§éƒ½æ˜¯ç»§æ‰¿çš„ï¼ˆé™¤éå®ƒä»¬æ˜¯ç§æœ‰çš„ï¼‰ã€‚
2ï¸âƒ£æ‚¨å¯ä»¥åœ¨å­ç±»ä¸­åˆ›å»ºæ–°çš„æ–¹æ³•ã€å±æ€§å’Œæ„é€ å‡½æ•°
3ï¸âƒ£æ‚¨å¯ä»¥è¦†ç›–ç°æœ‰æ–¹æ³•ï¼ˆæ„æ€æ˜¯ï¼šå½“ä¸€ä¸ªç±»ç»§æ‰¿äº†å¦ä¸€ä¸ªç±»åï¼Œå­ç±»å¯ä»¥é‡æ–°å®šä¹‰çˆ¶ç±»é‡Œå·²æœ‰çš„æ–¹æ³•ï¼Œï¼‰
4ï¸âƒ£ä¸€ä¸ªç±»åªèƒ½ç»§æ‰¿ä¸€ä¸ªç±»ï¼



9.overrideé‡å†™å’Œoverloadé‡è½½åŒºåˆ«
1ï¸âƒ£é‡å†™å‡ºç°åœ¨ç»§æ‰¿å…³ç³»ï¼ˆçˆ¶ç±»å’Œå­ç±»ä¹‹é—´ï¼‰ä¸­ï¼š
	â€¢	æ–¹æ³•ç­¾åå®Œå…¨ç›¸åŒï¼ˆåå­—ã€å‚æ•°ã€è¿”å›ç±»å‹ã€ä¿®é¥°ç¬¦éƒ½ç›¸åŒï¼‰
	â€¢	ä½†æ–¹æ³•å†…éƒ¨å®ç°ä¸åŒ

2ï¸âƒ£é‡è½½å‡ºç°åœ¨åŒä¸€ç±»ä¸­ï¼š
	â€¢	åŒä¸€ä¸ªç±»é‡Œï¼ˆderselben Klasseï¼‰
	â€¢	æ–¹æ³•åç›¸åŒï¼Œä½†ï¼š
	â€¢	å‚æ•°ä¸ªæ•°ä¸åŒï¼Œæˆ–
	â€¢	å‚æ•°ç±»å‹ä¸åŒï¼Œæˆ–
	â€¢	è®¿é—®ä¿®é¥°ç¬¦ä¸åŒ
	â€¢	åŠŸèƒ½ï¼šè®©åŒåæ–¹æ³•æœ‰å¤šç§â€œè¾“å…¥å½¢å¼â€


âœ…ä¸€å¥è¯æ€»ç»“ï¼š
é‡è½½ï¼ˆÃœberladenï¼‰ = åŒç±»ä¸­ï¼ŒåŒåä¸åŒå‚æ•°ï¼›
é‡å†™ï¼ˆÃœberschreibenï¼‰ = å­ç±»ä¸­ï¼Œå®Œå…¨åŒååŒå‚â€¼ï¸ä½†é‡å†™å®ç°ã€‚


10.é™æ€ç±»å‹å’ŒåŠ¨æ€ç±»å‹â€¼ï¸â€¼ï¸å¾ˆéš¾
é™æ€ç±»å‹ï¼š
1ï¸âƒ£åœ¨ç¼–è¯‘æ—¶è®¾ç½®ã€‚
2ï¸âƒ£å†³å®šå…è®¸è®¿é—®å“ªäº›æ–¹æ³•å’Œå±æ€§ï¼ˆå¯¹äºå¯¹è±¡ï¼‰ã€‚
3ï¸âƒ£æ¢å¥è¯è¯´ï¼Œå®ƒé™åˆ¶äº†åŠ¨æ€ç±»å‹å¯¹å¤–ç•Œå¯è§çš„å†…å®¹ã€‚
åŠ¨æ€ç±»å‹ï¼š
1ï¸âƒ£åœ¨è¿è¡Œæ—¶ç¡®å®šã€‚
2ï¸âƒ£å†³å®šå®é™…æ‰§è¡Œæ–¹æ³•çš„å“ªä¸ªå®ç°ã€‚
3ï¸âƒ£åŒ…å«å…·ä½“å¯¹è±¡çš„å±æ€§å’Œæ„é€ å‡½æ•°é€»è¾‘çš„å…·ä½“å€¼ã€‚


11.å¤šæ€
åœ¨è¿è¡Œæ—¶ï¼ˆLaufzeitï¼‰ï¼Œç¨‹åºæ ¹æ®**å¯¹è±¡çš„çœŸå®ç±»å‹ï¼ˆdynamischer Typï¼‰**æ¥å†³å®šè°ƒç”¨å“ªä¸ªæ–¹æ³•ï¼Œè€Œä¸æ˜¯æ ¹æ®å¼•ç”¨çš„å£°æ˜ç±»å‹ï¼ˆstatischer Typï¼‰ã€‚è§ä¸‹â¬‡ï¸

ä¾‹å¦‚ï¼š
class Animal {
    void makeSound() {
        System.out.println("sound");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("wow");
    }
}

Animal a1 = new Animal();
Animal a2 = new Dog();

a1.makeSound(); // è¾“å‡º sound
a2.makeSound(); // è¾“å‡º wow

â€¼ï¸æ¯”å¦‚è¿™é‡Œa2å£°æ˜æ˜¯Animalä½†æ˜¯å®é™…è¿è¡Œçš„æ—¶å€™å¼•ç”¨çš„æ˜¯ä¸€ä¸ª Dog å¯¹è±¡ï¼Œæ‰€ä»¥è¾“å‡ºwow
â€¼ï¸â€¼ï¸ä½†æ˜¯â—ï¸ä½†è¿™ä¸ªåŸåˆ™åªé€‚ç”¨äºï¼šå­ç±»é‡å†™ï¼ˆÃœberschreibenï¼‰çˆ¶ç±»å·²æœ‰çš„æ–¹æ³•ã€‚â€¼ï¸å®ƒä¸é€‚ç”¨äºè®¿é—®å­ç±»â€¼ï¸æ–°å¢åŠ çš„æ–¹æ³•ã€‚
public class Tier {
    public void laufen() {
        System.out.print("Das Tier lÃ¤uft. ");
    }
}

public class Hund extends Tier {
    public void bellen() {///ğŸ†•æ–°å¢åŠ çš„æ–¹æ³•
        System.out.print("Der Hund bellt.");
    }
}
Tier t = new Hund();
t.laufen();
t.bellen();âŒ

ğŸ‘‰ ä¸ºä»€ä¹ˆè¿™æ¬¡ä¸è¡Œï¼Ÿ
ç¼–è¯‘æ—¶ï¼šç¼–è¯‘å™¨çœ‹é™æ€ç±»å‹ Tierï¼Œå»æ‰¾æœ‰æ²¡æœ‰ bellen() â†’ âŒ æ²¡æœ‰
æ‰€ä»¥ä»£ç æ ¹æœ¬ç¼–è¯‘ä¸è¿‡ï¼Œæ ¹æœ¬è¿˜æ²¡åˆ°â€œè¿è¡Œæ—¶â€çš„é˜¶æ®µã€‚

æ¢å¥è¯è¯´ï¼š
å¤šæ€åªåœ¨**â€œå…±åŒâ€¼ï¸å­˜åœ¨äºçˆ¶ç±»å’Œå­ç±»â€**çš„æ–¹æ³•ä¹‹é—´èµ·ä½œç”¨ã€‚â€¼ï¸â€¼ï¸
å¦‚æœçˆ¶ç±»æ ¹æœ¬æ²¡è¿™æ–¹æ³•ï¼Œç¼–è¯‘å™¨è¿â€œå¤šæ€çš„å…¥å£â€éƒ½æ‰¾ä¸åˆ°ã€‚


ğŸ¤”é‚£å¤šæ€èµ·åˆ°ä¸€ä¸ªä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿé™æ€å£°æ˜ä¸åŒï¼Œè®©ä»–åœ¨è¿è¡Œçš„æ—¶å€™çœ‹å®é™…çš„ç±»å‹ã€‚
1ï¸âƒ£è®©åŒä¸€å¥—ä»£ç å¯ä»¥å¤„ç†ä¸åŒçš„å¯¹è±¡ç±»å‹
2ï¸âƒ£è®©ç¨‹åºæ›´çµæ´»ã€æ›´å¯æ‰©å±•
3ï¸âƒ£éšè—å®ç°ç»†èŠ‚ï¼ˆæ¥å£æŠ½è±¡ï¼‰




12.ç»§æ‰¿å’Œæ„é€ å™¨
å­ç±»ä¸ä¼šç»§æ‰¿çˆ¶ç±»çš„æ„é€ å‡½æ•°ï¼Œä½†æ¯æ¬¡åˆ›å»ºå­ç±»å¯¹è±¡æ—¶ï¼Œçˆ¶ç±»æ„é€ å‡½æ•°ä¸€å®šä¼šå…ˆè¢«æ‰§è¡Œã€‚
è‹¥çˆ¶ç±»æ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼Œå°±å¿…é¡»åœ¨å­ç±»æ„é€ å‡½æ•°ç¬¬ä¸€è¡Œæ˜¾å¼å†™ super(...)ã€‚
class Parent {
    Parent(int x) {} // åªæœ‰æœ‰å‚æ„é€ å‡½æ•°
}

class Child extends Parent {
    Child() {
        super(10); // âœ… å¿…é¡»æ˜¾å¼è°ƒç”¨ï¼Œå› ä¸ºçˆ¶ç±»æ²¡æœ‰é»˜è®¤æ„é€ 
    }
}
ğŸ”¸ è€Œä¸”ï¼š
super(...) å¿…é¡»æ˜¯å­ç±»æ„é€ å‡½æ•°çš„ç¬¬ä¸€è¡Œè¯­å¥ï¼
å¦åˆ™ç¼–è¯‘ä¼šæŠ¥é”™ã€‚

é»˜è®¤æ„é€ å‡½æ•°ï¼šæ²¡æœ‰å‚æ•°çš„æ„é€ å‡½æ•°ã€‚
å¦‚æœä½ æ²¡æœ‰å†™ä»»ä½•æ„é€ å‡½æ•°ï¼ŒJava ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä¸ºä½ ç”Ÿæˆä¸€ä¸ªè¿™æ ·çš„æ— å‚æ„é€ å‡½æ•°ã€‚
ä¾‹å¦‚ï¼š
æˆ‘ä»¬å†™æ²¡æœ‰å‚æ•°çš„æ„é€ å‡½æ•°
class Cat {
    String name;
}
Java ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªï¼š
Cat() { }      è¿™å°±æ˜¯é»˜è®¤æ„é€ å‡½æ•°

â€¼ï¸ä¹Ÿå°±æ˜¯è¯´ï¼šå¦‚æœçˆ¶ç±»è‡ªå·±æ„é€ äº†ä¸€ä¸ªæœ‰å‚å‡½æ•°ï¼Œé‚£ä¹ˆå­ç±»å¿…é¡»åœ¨ç¬¬ä¸€è¡Œå†™super;çˆ¶ç±»å¦‚æœæ˜¯æ— å‚å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯çˆ¶ç±»æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆsuperå°±å¯ä»¥ä¸ç”¨å†™ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æä¾›
ğŸ§ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšï¼Ÿ
å› ä¸ºä¸€ä¸ªå­ç±»å¯¹è±¡ï¼Œå…¶å®æ˜¯â€œåŒ…å«äº†çˆ¶ç±»éƒ¨åˆ† + å­ç±»éƒ¨åˆ†â€çš„ä¸€ä¸ªæ•´ä½“ç»“æ„ã€‚
ä½ è¦å»ºäºŒæ¥¼ï¼ˆå­ç±»å¯¹è±¡ï¼‰æ—¶ï¼Œå¿…é¡»å…ˆè®©ä¸€æ¥¼ï¼ˆçˆ¶ç±»ï¼‰ç»“æ„ç¨³å®šï¼ˆsuper()ï¼‰ï¼Œå¦åˆ™äºŒæ¥¼å»ºä¸Šå»å°±åå¡Œã€‚
è®©çˆ¶ç±»ç»“æ„ç¨³å®šï¼Œä¹Ÿå°±æ˜¯è®©çˆ¶ç±»çš„å±æ€§å…ˆåˆå§‹åŒ–ï¼Œæ‰€ä»¥åœ¨çˆ¶ç±»è‡ªå·±æ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°çš„æ—¶å€™ï¼Œéœ€è¦æˆ‘ä»¬è‡ªå·±å†™superæ¥åˆå§‹åŒ–çˆ¶ç±»å±æ€§


13.Objektï¼šæ˜¯æ‰€æœ‰ç±»çš„çˆ¶ç±»

æ¯ä¸ªç±»éƒ½ä¼šè‡ªåŠ¨ç»§æ‰¿è‡ª Objectï¼Œå³ä½¿æ‚¨ä¸ç¼–å†™æ‰©å±•ã€‚
è¿™æ„å‘³ç€ - æ¯ä¸ªç±»éƒ½ç»§æ‰¿äº† Object çš„åŸºæœ¬æ–¹æ³•ï¼Œä¾‹å¦‚ï¼š

toString() â†’ è¿”å›å¯¹è±¡çš„å­—ç¬¦ä¸²è¡¨ç¤º
equals(Object o) â†’ æ¯”è¾ƒå¯¹è±¡å†…å®¹æ˜¯å¦ç›¸ç­‰
hashCode() â†’ è¿”å›å¯¹è±¡çš„å“ˆå¸Œå€¼ï¼ˆæ•°å€¼è¡¨ç¤ºï¼‰
getClass() â†’ è¿”å›å¯¹è±¡çš„è¿è¡Œæ—¶ç±»å‹ï¼ˆç±»ä¿¡æ¯ï¼‰


â€¦â€¦å„ä¸ªModuleçš„Codeå®ç°





Theorieè®¢æ­£ï¼š
1.ä»€ä¹ˆæ˜¯Konstruktorï¼Ÿ
Konstruktorï¼ˆæ„é€ å‡½æ•°ï¼‰ æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ–¹æ³•ï¼Œç”¨æ¥åœ¨åˆ›å»ºå¯¹è±¡æ—¶ï¼ˆnewï¼‰åˆå§‹åŒ–å¯¹è±¡çš„å±æ€§ã€‚

å®ƒæ˜¯å¯¹è±¡â€œå‡ºç”Ÿâ€æ—¶è‡ªåŠ¨æ‰§è¡Œçš„ç¬¬ä¸€æ®µä»£ç ï¼Œè´Ÿè´£æŠŠå¯¹è±¡ä»ä¸€å—ç©ºå†…å­˜å˜æˆä¸€ä¸ªå¯ç”¨ã€æœ‰å†…å®¹çš„å®ä¾‹ã€‚

class Cat {
    String name;
    int age;

    // è¿™æ˜¯æ„é€ å‡½æ•°
    Cat(String n, int a) {
        name = n;
        age = a;
    }
}


8.è§ä¸Šé¢ç¬”è®°11.å¤šæ€ï¼šæ­¤æ—¶ä¸æ˜¯overrideäº†çˆ¶ç±»çš„æ–¹æ³•ï¼Œè€Œæ˜¯å­ç±»çš„æ–°å¢æ–¹æ³•ï¼Œæ‰€ä»¥åªçœ‹è¿è¡Œæ—¶å€™çš„å®é™…ç±»å‹å¹¶ä¸é€‚ç”¨






Codefragenè®¢æ­£ï¼š
1.
public class Oberklasse {
    public Oberklasse() {
        System.out.println("Konstruktor der Oberklasse; ");
    }
}

public class Unterklasse extends Oberklasse {
    public Unterklasse() {
        System.out.println("Konstruktor der Unterklasse; ");
    }
}

è¾“å…¥ï¼šUnterklasse u = new Unterklasse();
è¯·é—®ä¼šè¾“å‡ºä»€ä¹ˆï¼Ÿ
ç­”æ¡ˆï¼šKonstruktor der Oberklasse;Konstruktor der Unterklasse; 

å› ä¸ºï¼š
1ï¸âƒ£ é¦–å…ˆè°ƒç”¨ Unterklasse çš„æ„é€ å‡½æ•°
â†’ æ„é€ å‡½æ•°ç¬¬ä¸€è¡Œéšå¼åŒ…å« super()
2ï¸âƒ£ æ‰€ä»¥å…ˆå»æ‰§è¡Œ Oberklasse çš„æ„é€ å‡½æ•°
â†’ è¾“å‡º "Konstruktor der Oberklasse; "
3ï¸âƒ£ ç„¶åå†æ‰§è¡Œå­ç±»æ„é€ å‡½æ•°é‡Œçš„ä»£ç 
â†’ è¾“å‡º "Konstruktor der Unterklasse; "



2.è¿™ä¸¤ä¸ªæ–¹æ³•èƒ½å…±å­˜å—ï¼Ÿï¼ˆèƒ½å¦æ„æˆâ€œé‡è½½â€ï¼‰
public class Test {
    public int add(int a, int b) {
        return a + b;
    }

    public void add(int a, int b) {
        System.out.println(a + b);
    }
}

åˆ¤æ–­æ ‡å‡†ï¼šSignaturç›¸åŒï¼Œå®ç°ä¸åŒ
åœ¨ Java ä¸­ï¼Œæ–¹æ³•çš„å”¯ä¸€æ ‡è¯†ï¼ˆç­¾åï¼‰æ˜¯ç”±ä»¥ä¸‹ä¸¤éƒ¨åˆ†ç»„æˆçš„ï¼šæ–¹æ³•å + å‚æ•°åˆ—è¡¨ï¼ˆç±»å‹ä¸æ•°é‡ï¼‰

âš ï¸ ä¸åŒ…æ‹¬ï¼š
	â€¢	è¿”å›ç±»å‹ï¼ˆintã€void ç­‰ï¼‰
	â€¢	ä¿®é¥°ç¬¦ï¼ˆpublicã€privateï¼‰
	â€¢	æŠ›å‡ºå¼‚å¸¸ç±»å‹
ä¹Ÿå°±æ˜¯è¯´ï¼šâ†’ ä¸¤ä¸ªæ–¹æ³•çš„ç­¾åå®Œå…¨ç›¸åŒï¼Œè¿”å›ç±»å‹ä¸åŒè€Œå·²ã€‚
Java ä¸å…è®¸ä»…é â€œè¿”å›ç±»å‹ä¸åŒâ€æ¥åŒºåˆ†ä¸¤ä¸ªæ–¹æ³•ã€‚å› æ­¤ä¼šå‡ºç°ç¼–è¯‘é”™è¯¯


3.Beim Ãœberschreiben kann die Sichtbarkeit der Methode verringert werdenâŒ
Sichtbarkeitå¯è§åº¦é™ä½ï¼Œä¹Ÿå°±æ˜¯protectedæ”¹æˆprivate ä¸å…è®¸








Recap4 11ğŸˆ·ï¸17æ—¥

å‰æƒ…å›é¡¾ï¼šï¼ˆæ‘˜è‡ªJavaè‡ªå­¦ç¬”è®°-Readmeï¼‰
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
10.3
æ¥å£ä¸­æ‰€æœ‰éƒ½æ˜¯æŠ½è±¡æ–¹æ³•ï¼Œä¸å¯ä»¥æœ‰æ­£å¸¸æ–¹æ³•
æ¥å£ä¸­æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯public
æ‰€ä»¥è¿™ç§æƒ…å†µä¸‹çš„public abstractæ˜¯å·²ç»é»˜è®¤ã€å¯ä»¥çœç•¥çš„

public interface æ¥å£å è¿™é‡Œçš„interfaceæ˜¯å£°æ˜ä»–å·²ç»ä¸æ˜¯ç±»ï¼Œä½†æ˜¯è·Ÿç±»å¾ˆåƒ
æ¥å£é ç±»å®ç°
èƒ½ç»§æ‰¿æ¥å£çš„åªèƒ½æ˜¯æ¥å£ï¼Œæ¥å£å’Œç±»åªèƒ½æ˜¯å®ç°å…³ç³»implements
å•ç»§æ‰¿ï¼Œå¤šå®ç°
æ¥å£ä¸­æ‰€æœ‰å˜é‡éƒ½æ˜¯å…¨å±€é™æ€å¸¸é‡ï¼ˆä¹Ÿå°±æ˜¯final ä¸èƒ½é‡æ–°èµ‹å€¼ï¼‰

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œä¸€ä¸ªå®ç°æ¥å£çš„ç±»å’Œä¸€ä¸ªå®ç°æŠ½è±¡ç±»çš„å­ç±»æ˜¯å®Œå…¨ç­‰åŒçš„å—ï¼Ÿ
ä¸æ˜¯ï¼š	
1.	ç»§æ‰¿æ–¹å¼ä¸åŒ
	â€¢	ç±»åªèƒ½ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»ï¼ˆå•ç»§æ‰¿ï¼‰ã€‚
	â€¢	ç±»å¯ä»¥å®ç°å¤šä¸ªæ¥å£ï¼ˆå¤šå®ç°ï¼‰ã€‚âš ï¸ï¼ˆæ˜¯å¯¹äºç±»æ¥è®² å•ç»§æ‰¿ï¼šåªèƒ½ç»§æ‰¿ä¸€ä¸ª å¤šå®ç°ï¼šèƒ½å®ç°å¤šä¸ªï¼‰
2.	å†…å®¹ä¸åŒ
	â€¢	æŠ½è±¡ç±»å¯ä»¥æœ‰ï¼šæ„é€ å™¨ã€æ™®é€šæ–¹æ³•ã€å­—æ®µã€‚
	â€¢	æ¥å£æ—©æœŸåªèƒ½æœ‰ï¼šæŠ½è±¡æ–¹æ³•ã€‚
	â€¢	Java 8+ æ¥å£å¯ä»¥æœ‰ default æ–¹æ³•ï¼ˆå¸¦å®ç°ï¼‰ã€static æ–¹æ³•ã€‚
3.	è®¾è®¡ç›®çš„ä¸åŒ
	â€¢	æŠ½è±¡ç±» = è¡¨è¾¾â€œæ˜¯ä¸€ç§ï¼ˆis-aï¼‰â€å…³ç³»ã€‚
ï¼ˆä¾‹ï¼šDog extends Animal â†’ ç‹—æ˜¯ä¸€ç§åŠ¨ç‰©ï¼‰
	â€¢	æ¥å£ = è¡¨è¾¾â€œèƒ½åšä»€ä¹ˆï¼ˆcan-doï¼‰â€å…³ç³»ã€‚
ï¼ˆä¾‹ï¼šDog implements Runnable â†’ ç‹—èƒ½è·‘ï¼‰

1.å¯¹æ¯”ç†è§£
ä½ å¯ä»¥è¿™æ ·ç±»æ¯”ï¼š
	â€¢	æŠ½è±¡ç±» â†’ æ¨¡æ¿ï¼šè§„å®šâ€œå®¶æ—å…±æ€§â€ï¼Œä½†ä¸å®Œæ•´ï¼Œå­ç±»è¦è¡¥å…¨ã€‚
	â€¢	æ¥å£ â†’ å¥‘çº¦ï¼šè§„å®šâ€œåŠŸèƒ½è§„èŒƒâ€ï¼Œå®ç°ç±»è¦ç­¾åˆåŒï¼Œæ‰¿è¯ºâ€œæˆ‘è¦å®ç°è¿™äº›åŠŸèƒ½â€ã€‚

	â€¢	å®ç°æ¥å£çš„ç±» å¯ä»¥åŒæ—¶å®ç°å¤šä¸ªæ¥å£ï¼Œè€Œç»§æ‰¿æŠ½è±¡ç±»åªèƒ½ä¸€ä¸ªã€‚
	â€¢	æ¥å£é‡Œæ–¹æ³•çš„â€œæŠ½è±¡â€æ›´çº¯ç²¹ï¼ˆæ—©æœŸæ²¡æœ‰ä»»ä½•å®ç°ï¼‰ï¼ŒæŠ½è±¡ç±»åˆ™æ˜¯â€œæŠ½è±¡+éƒ¨åˆ†å®ç°â€çš„æ··åˆä½“ã€‚
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


1.æŠ½è±¡ç±»ä¸å¯ä»¥åˆ›å»ºå¯¹è±¡ï¼šå› ä¸ºæŠ½è±¡ç±»æ˜¯ä¸å®Œæ•´çš„ç±»ï¼Œå› ä¸ºæŠ½è±¡æ–¹æ³•æ²¡æœ‰å®ç°
åˆ›å»ºå¯¹è±¡ = å¿…é¡»ä¿è¯å¯¹è±¡çš„æ‰€æœ‰è¡Œä¸ºéƒ½æ˜¯å¯æ‰§è¡Œçš„ã€‚

2.æŠ½è±¡ç±»å’Œæ¥å£çš„åº”ç”¨æƒ…å†µï¼šå¤šä¸ªç±»å…·æœ‰ç›¸ä¼¼çš„ä»»åŠ¡ï¼Œä½†å®ç°ä¸åŒ
æŠ½è±¡ç±»/æ¥å£å¯ä»¥æŠ½å‡ºé€šç”¨éƒ¨åˆ†ï¼Œé¿å…é‡å¤ä»£ç 

â€¼ï¸
class Dog { void makeSound() { bark } }
class Cat { void makeSound() { meow } }
class Bird { void makeSound() { tweet } }

âœ…æŠ½è±¡ç±»ä¾‹å­ï¼š
ä½ æŠŠå…±åŒçš„ä¸œè¥¿æ”¾åˆ°æŠ½è±¡ç±»é‡Œï¼š
abstract class Animal {
    void eat() { ... }      // é€šç”¨å®ç°
    void sleep() { ... }    // é€šç”¨å®ç°
    abstract void makeSound();
}


å†è®©å…·ä½“ç±»ç»§æ‰¿ï¼š
class Dog extends Animal {
    void makeSound() { bark }
}

class Cat extends Animal {
    void makeSound() { meow }
}



âœ…æ¥å£ä¾‹å­ï¼š

class Bird extends Animal { }
class Plane extends Machine { }
class SuperMan extends Human { }
å®ƒä»¬æ²¡æœ‰ä»»ä½•å…±åŒçš„çˆ¶ç±»ï¼ˆé™¤äº† Objectï¼‰ï¼Œä½†éƒ½èƒ½â€œé£â€ã€‚
è¿™æ—¶ä½ ä¸èƒ½ç”¨æŠ½è±¡ç±»ï¼ˆå› ä¸ºæŠ½è±¡ç±»åªèƒ½å•ç»§æ‰¿ï¼Œè¿™é‡Œä»–ä»¬å·²ç»æœ‰çˆ¶ç±»äº†â€¼ï¸ï¼‰ã€‚
ğŸ¤”â€¼ï¸ä¹Ÿå°±æ˜¯è¯´åœ¨å‡ ä¸ªå­ç±»å·²ç»ç»§æ‰¿åˆ°ä¸åŒçš„ç‰¹å®šç±»ï¼Œå¹¶ä¸”æœ‰å…±åŒé€»è¾‘->æ¥å£

æ¥å£ï¼š
interface Flyable {void fly();}

è®©å…·ä½“ç±»å®ç°
class Bird extends Animal implements Flyable {}
class Plane extends Machine implements Flyable {}
class SuperMan extends Human implements Flyable {}

åŒä¸€ä¸ªç±»ä½“ç³» â†’ ç”¨æŠ½è±¡ç±»
ä¸åŒç±»ä½“ç³» â†’ ç”¨æ¥å£


3.æŠ½è±¡ç±»å½“ä¸­å¯ä»¥æ²¡æœ‰æŠ½è±¡æ–¹æ³•â€¼ï¸

å› ä¸º Java çš„è§„åˆ™æ˜¯ï¼š
åªè¦ç±»è¢«å£°æ˜æˆ abstractï¼Œå°±ä¸å…è®¸å®ä¾‹åŒ–ã€‚
è‡³äºé‡Œé¢æœ‰æ²¡æœ‰ abstract æ–¹æ³•ï¼Œæ˜¯ä¸¤å›äº‹ã€‚


4.å¯¹äºæŠ½è±¡ç±»çš„å­ç±»ï¼šâ€¼ï¸
å­ç±»åº”å½“å®ç°æ‰€æœ‰â€¼ï¸æŠ½è±¡æ–¹æ³•ã€‚
å¦‚æœå­ç±»æ²¡æœ‰å®ç°æ‰€æœ‰æŠ½è±¡æ–¹æ³•ï¼Œä¹Ÿå¿…é¡»å£°æ˜ä¸ºæŠ½è±¡ç±»ï¼ 


5.æ¥å£ï¼š
ä»…åŒ…å«æ–¹æ³•ç­¾åï¼›æ— æ„é€ å™¨â€¼ï¸ï¼›æ‰€æœ‰å­—æ®µå‡ä¸ºpublic static finalå­—æ®µï¼ˆå³å¸¸æ•°ï¼‰â€¼ï¸
ä¸€ä¸ªç±»å¯ä»¥å®ç°å¤šä¸ªæ¥å£â€¼ï¸ï¼›æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯å…¬æœ‰çš„â€¼ï¸

å¦‚æœæƒ³è®©æ¥å£èƒ½å¢åŠ æ–°æ–¹æ³•ï¼Œè€Œä¸ä¼šè®©æ‰€æœ‰ä»¥å‰çš„å®ç°ç±»æŠ¥é”™ï¼Œç”¨defaultâ€¼ï¸
â€”â€”â€”â€”> æ‰€æœ‰æ²¡æœ‰è¦†ç›–è¿™ä¸ªæ–¹æ³•çš„å­ç±»éƒ½ä¼šè‡ªåŠ¨ä½¿ç”¨å®ƒã€‚
ä¸ºä»€ä¹ˆè¿™æ ·å­ï¼Ÿæ˜¯ä¸ºäº†è®©æ¥å£åœ¨ç°ä»£ Java ä¸­å˜å¾—â€œä¸é‚£ä¹ˆåƒµç¡¬â€ï¼Œå…·å¤‡ä¸€ç‚¹ç‚¹æŠ½è±¡ç±»çš„èƒ½åŠ›ï¼ˆä»£ç å¤ç”¨ï¼‰ï¼Œä»¥æå‡çµæ´»æ€§å’Œå¯æ‰©å±•æ€§ã€‚



6.æŠ½è±¡ç±»å’Œæ¥å£çš„å…±åŒä¹‹å¤„ï¼š
ä¸èƒ½å®ä¾‹åŒ–ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½åˆ›å»ºå¯¹è±¡ï¼›

å¯ä»¥ä½œä¸ºé™æ€ç±»å‹ä½¿ç”¨ï¼Œä½†ä¸èƒ½ä½œä¸ºåŠ¨æ€ç±»å‹ä½¿ç”¨ã€‚
Animal a = new Dog();
â†‘é™æ€ç±»å‹   â†‘åŠ¨æ€ç±»å‹
ä¹Ÿå°±æ˜¯è¯´ï¼šä½ å¯ä»¥ç”¨â€œæ¥å£â€æˆ–â€œæŠ½è±¡ç±»â€å½“ä½œå˜é‡çš„ç±»å‹ï¼ˆå·¦è¾¹ï¼‰ï¼Œä½†ä½ ä¸èƒ½ new å®ƒä»¬ï¼ˆå³è¾¹ï¼‰ã€‚
âœ…
Animal a;         // æŠ½è±¡ç±»ä½œä¸ºé™æ€ç±»å‹ OK
Moveable m;       // æ¥å£ä½œä¸ºé™æ€ç±»å‹ OK

Animal a = new Dog(); 
Moveable m = new Robot();
âŒ
new Animal();   // æŠ½è±¡ç±»ä¸èƒ½ä½œä¸ºåŠ¨æ€ç±»å‹ï¼ˆä¸èƒ½è¢«å®ä¾‹åŒ–ï¼‰
new Moveable(); // æ¥å£ä¸èƒ½ä½œä¸ºåŠ¨æ€ç±»å‹ï¼ˆä¸èƒ½è¢«å®ä¾‹åŒ–ï¼‰



7.è¯¾ä»¶ç¬¬13é¡µé”™è¯¯çš„åŸå› æ˜¯ï¼šAnimalæ˜¯æŠ½è±¡ç±»ï¼Œä¸èƒ½å®ä¾‹åŒ–ï¼Œä¸èƒ½newâ€¼ï¸
è¯¾ä»¶ç¬¬15é¡µï¼šå­ç±»ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå®ç°ä¸€ä¸ªæ¥å£ï¼Œä½†åªå®ç°äº†æŠ½è±¡ç±»ä¸­çš„æŠ½è±¡æ–¹æ³•ï¼Œæ¥å£ä¸­çš„æ²¡æœ‰å®ç°ï¼Œé‚£ä¹ˆè¿™ä¸ªå­ç±»ä¸ºæŠ½è±¡ç±»




8.ä¸€ä¸ªç±»æ˜¯å¦èƒ½å®ä¾‹åŒ–ï¼ˆèƒ½ä¸èƒ½ newï¼‰å–å†³äºå®ƒæ˜¯å¦æ˜¯â€œå®Œæ•´ç±»â€ã€‚

â€œå®Œæ•´ç±»â€æ„å‘³ç€ï¼š
	â€¢	æ²¡æœ‰ä»»ä½•å°šæœªå®ç°çš„æ–¹æ³•
	â€¢	æ²¡æœ‰ä»»ä½• abstract æ–¹æ³•
	â€¢	çˆ¶ç±»å’Œæ¥å£ä¸­è¦æ±‚å®ç°çš„æ–¹æ³•å…¨éƒ¨å·²ç»å®ç°
	â€¢	é€»è¾‘ä¸Šå¯ä»¥æ­£å¸¸æ‰§è¡Œæ‰€æœ‰æ–¹æ³•

åªè¦æ»¡è¶³è¿™äº› â†’ å°±å¯ä»¥ newã€‚



9.ä¸ºä»€ä¹ˆæ¥å£ä¸èƒ½æœ‰æ„é€ å™¨è€ŒæŠ½è±¡ç±»å¯ä»¥ï¼Ÿ
æ„é€ å™¨å­˜åœ¨çš„æ„ä¹‰åªæœ‰ä¸€ä¸ªï¼šåˆå§‹åŒ–å¯¹è±¡çš„çŠ¶æ€ï¼ˆå­—æ®µï¼‰ã€‚
æ¥å£æ²¡æœ‰å¯¹è±¡ â†’ æ‰€ä»¥ä¸éœ€è¦æ„é€ å™¨
ğŸ¤”ä½†ä¸ºä»€ä¹ˆæŠ½è±¡ç±»å¯ä»¥æœ‰æ„é€ å™¨ï¼Œå®ƒä¹Ÿä¸èƒ½æœ‰å¯¹è±¡ï¼Ÿ
å› ä¸ºæŠ½è±¡ç±»æœ¬è´¨æ˜¯â€œä¸€ä¸ªä¸å®Œæ•´çš„ç±»â€ï¼Œä½†ä»ç„¶æ˜¯â€œç±»â€â€¼ï¸ã€‚æ¥å£ä¸æ˜¯ç±»ï¼Œå®ƒæ˜¯èƒ½åŠ›æè¿°ã€‚â€¼ï¸



10.åŒ¿åç±»ï¼šæ²¡æœ‰è‡ªå·±çš„åå­—/åªèƒ½å®ç°ä¸€æ¬¡/ä¸èƒ½å®šä¹‰æ„é€ å™¨ï¼ˆå› ä¸ºæ²¡æœ‰ç±»åï¼‰

abstract class Animal {
abstract void doSound();
}

Animal cat = new Animal() {
    void doSound(){ System.out.println("Myao"); }
};
ä½ åœ¨ new çš„ä¸æ˜¯ Animalã€‚
å› ä¸º Animal æ˜¯æŠ½è±¡ç±»ï¼Œä¸èƒ½ newã€‚

ğŸ‘‰ ä½ å®é™…ä¸Šæ˜¯åœ¨ new ä¸€ä¸ªâ€œä¸´æ—¶ç”Ÿæˆçš„å­ç±»â€ã€‚â€¼ï¸
è¿™ä¸ªå­ç±»ç»§æ‰¿ Animalï¼Œå¹¶å®ç°äº† doSound()ã€‚

ğŸ‘‰ ä½†è¿™ä¸ªå­ç±»æ²¡æœ‰ç±»åã€‚






Theorieè®¢æ­£ï¼š
1.æŠ½è±¡ç±»å’Œæ¥å£çš„ä¸»è¦ç›®çš„ï¼š
Eine abstrakte Klasse bildet die Grundlage fÃ¼r eine Klassenhierarchie.æŠ½è±¡ç±»ç”¨æ¥å»ºç«‹ä¸€ä¸ªâ€œç±»æ—è°±â€ï¼ˆç»§æ‰¿ä½“ç³»ï¼‰ã€‚
Ein Interface definiert welche Methoden oder FunktionalitÃ¤ten eine Klasse bereitstellen muss. æ¥å£å®šä¹‰â€œè¿™ä¸ªç±»å¿…é¡»èƒ½åšä»€ä¹ˆâ€ã€‚

2.Alle Methoden in einem Interface sind automatisch publicâœ…åœ¨ interface é‡Œï¼Œæ–¹æ³•çš„è®¿é—®ä¿®é¥°ç¬¦æ°¸è¿œéƒ½æ˜¯ publicï¼Œå³ä½¿ä½ ä¸å†™ï¼ŒJava ä¹Ÿä¼šè‡ªåŠ¨å½“ä½œ publicã€‚
Ein Interface kann mehrere andere Interfaces erweiternâ€¼ï¸æ¥å£å±…ç„¶å¯ä»¥ç»§æ‰¿å¤šä¸ªæ¥å£ï¼Œå•ç»§æ‰¿å¤šå®ç°åªæ˜¯å¯¹ç±»ï¼Œå•ç»§æ‰¿ä¸€ä¸ªç±»ï¼Œå¤šå®ç°å¤šä¸ªæ¥å£
Ein Interface kann (seit Java8) Methoden mit Implementation enthalten

â“ä¸ºä»€ä¹ˆæ¥å£å¯ä»¥ç»§æ‰¿å¤šä¸ªæ¥å£ï¼Ÿ
å› ä¸ºæ¥å£æ²¡æœ‰å­—æ®µã€æ„é€ å™¨ã€å¤æ‚å®ç° â†’ ä¸ä¼šæœ‰å†²çª â†’ èƒ½åšèƒ½åŠ›ç»„åˆã€‚â€¼ï¸


3.æŠ½è±¡ç±»å’Œæ¥å£çš„å…±åŒä¹‹å¤„
Beide kÃ¶nnen mehrere Interfaces implementieren/erweiternâ€¼ï¸è¿™é‡Œçš„erweiternâ€¼ï¸æ˜¯ç»§æ‰¿çš„æ„æ€ğŸ˜“
Beide kÃ¶nnen nicht direkt instanziiert werden
Beide kÃ¶nnen konkrete (implementierte) Methoden enthalten







Codefragenè®¢æ­£ï¼š

1.âŒ
public abstract class MyBot{
    private abstract int xPosition;
    private abstract int yPosition;
    
    public abstract MyBot(int x, int y);
}

æŠ½è±¡ç±»å¯ä»¥æ²¡æœ‰æŠ½è±¡æ–¹æ³•ï¼Œæ¯”å¦‚
abstract class A {
    void f() {}
}
ä½†æ˜¯è¿™é‡Œçš„é—®é¢˜ä¸æ˜¯è¿™ä¸ªï¼Œ1.æ˜¯å­—æ®µä¸èƒ½æ˜¯abstractâ€¼ï¸2.æ„é€ å™¨ä¸èƒ½æ˜¯ abstractâ€¼ï¸
1ï¸âƒ£å› ä¸ºï¼š
å­—æ®µæœ¬è´¨æ˜¯æ•°æ®ï¼ˆæ•°æ®ä¸å¯èƒ½â€œæœªå®ç°â€â€¼ï¸ï¼‰
abstract çš„æ„ä¹‰æ˜¯â€œå¿…é¡»ç”±å­ç±»å®ç°â€
å­—æ®µæ²¡æœ‰â€œå®ç°â€â€¼ï¸ï¼Œåªæœ‰â€œå€¼â€
æ‰€ä»¥å­—æ®µä¸å¯èƒ½è¢«æ ‡è®°ä¸º abstractâœ…

2ï¸âƒ£å› ä¸ºï¼š
abstract = â€œç”±å­ç±»å®ç°â€
æ„é€ å™¨ = â€œåˆå§‹åŒ–è¿™ä¸ªç±»è‡ªèº«â€
æ„é€ å™¨ä¸èƒ½è¢«ç»§æ‰¿ï¼Œæ‰€ä»¥å­ç±»æ— æ³• override æ„é€ å™¨
â†’ æ‰€ä»¥ä¹Ÿä¸å¯èƒ½ â€œå®ç°â€ çˆ¶ç±»çš„æŠ½è±¡æ„é€ å™¨

æ„é€ å™¨ä¸èƒ½è¢«ç»§æ‰¿æ˜¯å› ä¸ºï¼šæ„é€ å™¨æœ¬è´¨æ˜¯â€œåˆå§‹åŒ–å½“å‰ç±»è‡ªèº«çš„å†…éƒ¨ç»“æ„â€ã€‚è¿™ä¸ªåˆå§‹åŒ–åŠ¨ä½œä¸èƒ½è¢«å­ç±»å¤ç”¨

è®°ä½ï¼š
ç±»ä¸­åªæœ‰ä¸¤ç§ä¸œè¥¿å¯ä»¥æ ‡è®° abstractï¼š
	1.	æŠ½è±¡ç±»æœ¬èº«
	2.	æŠ½è±¡æ–¹æ³•ï¼ˆæ²¡æœ‰æ–¹æ³•ä½“ï¼‰



2.âŒ
interface IntSolver{
    int solve(int first, int second);
}â€¼ï¸æ¥å£ä¸­çš„æ–¹æ³•è‡ªåŠ¨ = public abstract

class Addierer implements IntSolver {
    int solve(int first, int second){///âŒä½†è¿™é‡Œçš„æ²¡æœ‰å†™public â†’ é»˜è®¤æ˜¯ package-privateï¼ˆåŒ…å¯è§ï¼‰ã€‚
        return first + second;
    }
}
ä¹Ÿå°±æ˜¯è¯´ï¼š
	â€¢	æ¥å£æ–¹æ³•ï¼špublic
	â€¢	å®ç°æ–¹æ³•ï¼šé»˜è®¤å¯è§ï¼ˆæ›´å¼±ï¼‰




3.âŒ
interface A{
    default void apply(){
        System.out.print("Alice");
    }
}

interface B{
    default void apply(){
        System.out.print("Bob");
    }
}
Cç»§æ‰¿ä¸¤ä¸ªinterfaceï¼Œc.apply()ä¼šè¾“å‡ºä»€ä¹ˆï¼Ÿ
ç­”æ¡ˆï¼šEin Fehler

ä¸ºä»€ä¹ˆä¸èƒ½è‡ªåŠ¨åŒæ—¶è°ƒç”¨ä¸¤ä¸ªï¼Ÿ
ä¸è¡Œï¼Œå› ä¸ºï¼š
	â€¢	Java çš„ç»§æ‰¿è§„åˆ™ä¸å…è®¸è‡ªåŠ¨åˆå¹¶ default æ–¹æ³•çš„è¡Œä¸º
	â€¢	default ä¸æ˜¯â€œåˆå¹¶è¡Œä¸ºâ€ï¼Œåªæ˜¯ä¸€ä¸ªè½»é‡å®ç°
	â€¢	å¤šç»§æ‰¿å†²çªå¿…é¡»äººå·¥è§£å†³
è¿™æ˜¯ Java ä¸ºäº†é¿å…æ¨¡ç³Šè¡Œä¸ºè€Œå¼ºåˆ¶çš„è§„åˆ™ã€‚

æœ‰Namenkonfliktå¿…é¡»æ‰‹åŠ¨æ¶ˆé™¤ï¼š
âœ…
class C implements A, B {
    @Override
    public void apply() {
        A.super.apply();   // æˆ–è€… B.super.apply()
        // æˆ–ä¸¤è€…éƒ½è°ƒç”¨ï¼Œä½ è‡ªå·±å†³å®š
    }
}

ğŸ¤”ä¸ºä»€ä¹ˆå¿…é¡»ç”¨ A.super.apply() è¿™ç§å¥‡æ€ªçš„å†™æ³•ï¼Ÿ
è¿™èƒŒåæ˜¯ Java ä¸ºäº†è§£å†³å¤šæ¥å£ default æ–¹æ³•å†²çªè€Œè®¾è®¡çš„ä¸€ä¸ª ä¸“ç”¨è¯­æ³•ã€‚
æ²¡æœ‰è¿™ä¸ªè¯­æ³•ï¼Œç¼–è¯‘å™¨æ ¹æœ¬ä¸çŸ¥é“ä½ æƒ³è°ƒç”¨å“ªä¸€ä¸ª default æ–¹æ³•ã€‚

â€¼ï¸å› ä¸ºç±»å¯ä»¥å®ç°å¤šä¸ªæ¥å£ï¼ŒJava éœ€è¦ä½ æ˜ç¡®é€‰æ‹©è°ƒç”¨å“ªä¸€ä¸ªæ¥å£çš„ default æ–¹æ³•ï¼Œæ‰€ä»¥è¯­æ³•å¿…é¡»å†™æˆ InterfaceName.super.method()










Recap5 11ğŸˆ·ï¸29æ—¥
Thema 5 - Interfaces und abstrakte Klassen






















Recap6 12ğŸˆ·ï¸08æ—¥
Thema 6 - Grundlagen der funktionalen Programmierung

Racket
1ï¸âƒ£æ ¸å¿ƒæ€æƒ³ï¼šä½ æŠŠæ‰€æœ‰ä¸œè¥¿å½“â€œæ•°å­¦å‡½æ•°â€ä¸€æ ·ä½¿ç”¨ï¼Œä¸å»ä¿®æ”¹çŠ¶æ€ï¼Œä¸åˆ°å¤„èµ‹å€¼ã€‚
2ï¸âƒ£æ¥è‡ª Lisp å®¶æ— â†’ æ‰€ä»¥å®ƒé•¿å¾—åƒè¿™æ ·ï¼šâ“
(+ 1 2)
(define (f x) (* x x))
â“ï¼šæ‰€è°“ Lispï¼ˆLISt Processorï¼‰ï¼Œæœ¬è´¨å°±æ˜¯ï¼šæ•´ä¸ªç¨‹åºå°±æ˜¯ä¸€æ£µæ ‘ï¼Œè€Œâ€¼ï¸æ ‘åœ¨æ–‡æœ¬ä¸­çš„è¡¨ç¤ºæ–¹å¼å°±æ˜¯æ‹¬å·åµŒå¥—â€¼ï¸çš„åˆ—è¡¨â€¼ï¸ã€‚
æˆ‘ä»¬åªè¦ä¸€ç§ç»“æ„ â€”â€” Listã€‚å…¶ä»–æ‰€æœ‰ä¸œè¥¿ï¼ˆè¯­å¥ã€å‡½æ•°ã€è¡¨è¾¾å¼ï¼‰éƒ½ç”±å®ƒç»„æˆã€‚
â€¼ï¸å› ä¸ºè¿™æ ·çš„ç»“æ„éå¸¸é€‚åˆé€’å½’æ±‚å€¼
è§£æè§„åˆ™éå¸¸ç»Ÿä¸€ï¼š
è¦è®¡ç®—ä¸€ä¸ªè¡¨è¾¾å¼ï¼
â‘  è®¡ç®—åˆ—è¡¨ç¬¬ä¸€ä¸ªâ€¼ï¸å…ƒç´ ï¼ˆå¿…é¡»æ˜¯å‡½æ•°/æ“ä½œç¬¦ï¼‰ â€¼ï¸ï¼šæ‰€ä»¥é€‚åˆé€’å½’æ±‚å€¼
â‘¡ é€’å½’åœ°è®¡ç®—å…¶ä»–å…ƒç´ 
â‘¢ è°ƒç”¨å‡½æ•°

â€¼ï¸
1ï¸âƒ£cons çš„ä½œç”¨å°±æ˜¯â€œæŠŠä¸€ä¸ªå…ƒç´ æ”¾åœ¨åˆ—è¡¨å¤´éƒ¨â€
cons = prependï¼ˆå‰ç½®ï¼‰
= â€œæŠŠæŸä¸ªä¸œè¥¿æ”¾åˆ°åˆ—è¡¨æœ€å‰é¢â€
(cons 'a '(b c d)) ; => '(a b c d)
(cons 100 empty)   ; => '(100)
2ï¸âƒ£åŒ¿åå‡½æ•°
åŒ¿åå‡½æ•° = æ²¡æœ‰åå­—çš„å‡½æ•°ã€‚
å°±æ˜¯ä¸´æ—¶ç”¨ä¸€ä¸‹ã€ä¸æƒ³å®šä¹‰æˆç‹¬ç«‹å‡½æ•°çš„å‡½æ•°ã€‚
3ï¸âƒ£' ç¬¦å· æ˜¯ Racket/Lisp çš„â€œquoteâ€çš„ç¼©å†™
quote = ä¸è¦è®¡ç®—é‡Œé¢çš„è¡¨è¾¾å¼ï¼ŒæŠŠå®ƒå½“æˆåŸå§‹æ•°æ®ã€‚

4ï¸âƒ£(cons (map (lambda (x) (* x x)) '(2 3))
      '(10 20))
ç­”æ¡ˆï¼š'((4 9) 10 20)
â“ä¸ºä»€ä¹ˆè¾“å‡ºä¸€ä¸ªåˆ—è¡¨ è€Œå‰é¢è¿˜å¸¦quote
ä½œç”¨ï¼šREPL ç”¨ ' æ¥å‘Šè¯‰ä½ ï¼šâ€œæˆ‘æ˜¾ç¤ºçš„è¿™ä¸ªä¸œè¥¿æ˜¯æ•°æ®ï¼ˆlistï¼‰ï¼Œä¸æ˜¯ä»£ç ï¼ˆfunction callï¼‰ã€‚â€ ç”¨ quote åªæ˜¯é¿å…è¯¯è§£ï¼Œè®©ä½ ä¸€çœ¼çœ‹å‡ºå®ƒæ˜¯åˆ—è¡¨å­—é¢é‡ã€‚
æ¯”å¦‚æˆ‘ä»¬è¾“å…¥ï¼š(list 1 2 3)
Racketä¼šè¾“å‡ºï¼š'(1 2 3)
ä½†å†…éƒ¨å€¼å®é™…æ˜¯ï¼š(1 2 3)

5ï¸âƒ£ï¼šdefine
(define (name Parameterliste) (Implementation))
ğŸŒ°ä¾‹å­ï¼š
(define (add a b) (+ a b))
(add 2 3) ; Aufruf der Methode

6ï¸âƒ£Listen
(define lst '(1 2 3 4)) ; erstellt eine geordnete Liste mit den Elementen 1, 2, 3, 4
(first lst) ; liefert erstes Element der Liste: 1
(rest lst) ; liefert Rest der Liste ohne das erste Element: (2, 3, 4)
(cons 0 lst) ; fÃ¼gt 0 vorne an die Liste an
(length lst) ; Anzahl der Elemente
(append lst '(5 6)) ; Listen verketten
â€¼ï¸append ä¸ä¼šåœ¨å°¾éƒ¨ç›´æ¥æ‹¼æ¥ï¼ˆå› ä¸ºæ˜¯å•é“¾è¡¨ï¼‰ï¼Œè€Œæ˜¯å¤åˆ¶ + æ‹¼æ¥ï¼Œåˆ›å»ºæ–°åˆ—è¡¨
è¡Œä¸ºæ˜¯ï¼šåˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨ï¼Œå…ˆå¤åˆ¶ lst çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå†æ¥ä¸Š (5 6)ã€‚
ç»“æœï¼š'(1 2 3 4 5 6)
ä»ç„¶ä¸ä¿®æ”¹ lst æœ¬èº«ã€‚â€¼ï¸
(empty? lst) ; prÃ¼ft, ob eine Liste leer ist und gibt #t oder #f aus.

Hinweis:
Listen sind unverÃ¤nderlich â€“ neue Listen werden durch cons oder append erstellt.

7ï¸âƒ£Rekursion

(define (factorial n)
(if (= n 0)
1
(* n (factorial (- n 1)))))
(factorial 5) ; 120

Hinweise:
â— In Racket gibt es auch tail recursion fÃ¼r bessere Speicheroptimierung
âš ï¸è¿™é‡Œçš„ä¸æ˜¯å°¾é€’å½’
æ‰€ä»¥é€’å½’è°ƒç”¨åè¿˜æœ‰äº‹è¦åš â†’ ä¸æ˜¯å°¾è°ƒç”¨ã€‚
å°¾é€’å½’ = å‡½æ•°çš„æœ€åä¸€æ­¥æ˜¯é€’å½’è°ƒç”¨ï¼Œè€Œä¸”è°ƒç”¨å®Œä¹‹åæœ¬å±‚ä¸å†è¿›è¡Œä»»ä½•è¿ç®—ã€‚
ä¹Ÿå¯ä»¥ç†è§£ä¸ºé€’å½’åœ¨å°¾ï¼ˆåç»­æ²¡æœ‰ä»»ä½•å…¶ä»–è¿ç®—ï¼‰è°ƒç”¨ä¹‹åä¸å†æ‰§è¡Œä»»ä½•å…¶ä»–æ“ä½œã€‚




1.pure Functionsçº¯å‡½æ•°ï¼šåŒæ ·çš„è¾“å…¥ä¸€å®šæœ‰ç›¸åŒçš„è¾“å‡º

2.é¢„åˆ¶åŠŸèƒ½æ¥å£vordefinierte funktionale Interfaces
â— Comparator<T>
Methode: int compare(T a, T b)						
æ¯”è¾ƒå¹¶æ ¹æ®é¡ºåº (bzw liefert 1, 0 oder -1).
â— Function<T, R>
Methode: R apply(T t)
ReprÃ¤sentiert eine Funktion, die ein Argument vom Typ T nimmt und ein Ergebnis vom Typ R zurÃ¼ckgibt.
â— BiFunction<T, U, R>
Methode: R apply(T t, U u)
è¾“å…¥TUï¼Œè¿”å›Rç±»å‹
â— Consumer<T>
Methode: void accept(T t)
Verbraucht einen Wert T, fÃ¼hrt eine Aktion aus, gibt aber nichts zurÃ¼ck.â€¼ï¸ä¸è¿”å›
â— Predicate<T>
Methode: boolean test(T t)
Testet eine Bedingung fÃ¼r ein Objekt vom Typ T.

3.Lambdaè¡¨è¾¾å¼
/ Allgemeine Form:(parameterListe) -> { Anweisungen }

// Ausdruck mit RÃ¼ckgabewert (implizit)â€¼ï¸
(x) -> x * x
// Mit Typangabe
(Integer x) -> x * x
// Mit Block und return
(x) -> { return x * x; }

// Lambda: list.forEach(s -> System.out.println(s));
// Methodenreferenz: list.forEach(System.out-:println);

Es gibt folgende Typen von Methodenreferenzen:
â— object::method System.out::println 			æŸä¸ªâ€œå·²å­˜åœ¨å¯¹è±¡â€çš„æ–¹æ³•
â— Class::staticMethod Math::max					ç±»çš„é™æ€æ–¹æ³•
â— Class::instanceMethod String::toLowerCase		è°::ç”¨ä»€ä¹ˆæ–¹æ³•
Wird benutzt, wenn Lambda nur eine Methode verwendet

4.lambdaå‡½æ•°çš„è®¡ç®—ğŸŒ°ğŸŒ°ğŸŒ°

5.vordefinierte Methodeï¼š
map æŠŠå‡½æ•°æ˜ å°„åˆ°åˆ—è¡¨çš„æ¯ä¸€ä¸ªå…ƒç´ 


Theorieè®¢æ­£ï¼š
1.Was ist funktionale Programmierung?
a.Eine Methode zur Erstellung grafischer BenutzeroberflÃ¤chen
b.Ein Ansatz, bei dem NutzerwÃ¼nsche in User-Stories definiert und dann als einzelne Funktionen implementiert werden
c.Ein Programmierparadigma, das Funktionen als zentrale Bausteine verwendetâœ…
d.Ein Programmierstil, bei dem keine Funktionen oder Methoden erlaubt sind

2.Welche Merkmale treffen auf funktionale Programmierung zu?
a.Funktionen kÃ¶nnen als RÃ¼ckgabewerte verwendet werdenâœ…è¿™æ˜¯**å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼ˆfirst-class citizensï¼‰**çš„ç›´æ¥ä½“ç°ã€‚
b.Es wird hauptsÃ¤chlich objektorientiert programmiertâŒ
c.Funktionen sind Hauptbausteine und ersetzen somit Objekte und Vererbungâœ…åœ¨å‡½æ•°å¼èŒƒå¼ä¸­ï¼Œç¨‹åºç»“æ„ä¸»è¦é å‡½æ•°ç»„åˆï¼Œè€Œä¸æ˜¯å¯¹è±¡ç»“æ„
d.Variablen sind normalerweise unverÃ¤nderlich (immutable)âœ…è¿™æ˜¯å‡½æ•°å¼ç¼–ç¨‹æœ€ç›´è§‚çš„ç‰¹å¾
å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œå˜é‡é€šå¸¸æ˜¯ä¸å¯å˜çš„ï¼Œç¨‹åºé€šè¿‡åˆ›å»ºæ–°å€¼è€Œä¸æ˜¯ä¿®æ”¹æ—§å€¼æ¥æ¨è¿›è®¡ç®—ã€‚
	â€¢	mapï¼šä¸æ”¹åŸåˆ—è¡¨ â†’ äº§ç”Ÿæ–°åˆ—è¡¨
	â€¢	cons / appendï¼šä¸æ”¹æ—§åˆ—è¡¨ â†’ è¿”å›æ–°åˆ—è¡¨
	â€¢	lambdaï¼šä¸ä¾èµ–å¤–éƒ¨å¯å˜çŠ¶æ€
e.Funktionen kÃ¶nnen als Argumente Ã¼bergeben werdenâœ…

3.Welche Anforderungen muss ein funktionales Interface erfÃ¼llen?
a.Genau eine abstrakte Methode habenâœ…
b.Nur statische Methoden haben
c.Mehrere abstrakte Methoden, aber ohne Standardmethoden
d.Muss abstrakte Klassen erweitern

5.Was ist ein Seiteneffekt (Side Effect)?
a.Wenn eine Funktion ein Objekt erzeugt
b.Wenn eine Funktion eine oder mehrere lokale Variablen erzeug
c.Wenn eine Funktion eine Exception wirft
d.Wenn eine Funktion globale ZustÃ¤nde verÃ¤ndert oder I/O durchfÃ¼hrtâœ…å‡½æ•°é™¤äº†â€œè¿”å›å€¼â€ä»¥å¤–ï¼Œè¿˜å¯¹å‡½æ•°å¤–éƒ¨ä¸–ç•Œé€ æˆäº†å¯è§‚å¯Ÿçš„æ”¹å˜
ğŸŒ°ï¼š
x = x + 1;           // æ”¹å…¨å±€å˜é‡ï¼Œä½¿å¾—ç»“æœä¸æ­¢åªç”±è¾“å…¥å†³å®š
System.out.println  // I/O
writeFile(...)      // I/O
readInput(...)      // I/O
å‰¯ä½œç”¨ä¸æ˜¯â€œç¨‹åºæœ‰ååº”â€ï¼Œè€Œæ˜¯â€œç¨‹åºæ”¹äº†ä¸è¯¥æ”¹çš„ä¸œè¥¿â€ã€‚â€¼ï¸

6.Was ist â€Higher-Order Functionâ€œ (hÃ¶here Ordnung)?
a.Eine Funktion, die ein funktionales Interface implementiert
b.Eine Funktion, die andere Funktionen als Argument oder RÃ¼ckgabewert verwendetâœ…
c.Eine Funktion, die nur mit statischen Methoden arbeitet
d.Eine Funktion mit einer besonderen, komplizierten Aufgabe

7.Welche Aussagen Ã¼ber Lambda-AusdrÃ¼cke sind korrekt?
a.Lambdas sind eine kÃ¼rzere Schreibweise fÃ¼r anonyme Klassen mit einem funktionalen Interfaceâœ…
b.Lambdas kÃ¶nnen wiederverwendet werden, wenn sie in Variablen gespeichert werdenâœ…
c.Lambdas sind das Gegenteil von anonymen Funktionen
d.Lambdas ermÃ¶glichen es, Funktionen als Werte zu behandelnâœ…
e.Lambdas kÃ¶nnen als Parameter Ã¼bergeben werdenâœ…

8.Wie wird der Typ eines Lambda-Ausdrucks in Java bestimmt?
a.Der Typ muss explizit im Lambda-Ausdruck angegeben werden
b.Der Typ wird durch das Funktionsinterface bestimmt, das der Lambda-Ausdruck implementiertâœ…
c.Der Typ ist nicht erforderlich, Java erkennt ihn automatisch basierend auf dem RÃ¼ckgabewert
d.Der Typ wird automatisch durch die Argumenttypen des Lambda-Ausdrucks bestimmt

9.Wie sieht der minimale Lambda-Ausdruck in Java aus?
a.() -> return;
b.() ->
c.() -> {return null;}
d.() -> {return;}
e.() -> {}âœ…
Lambda æœ‰ä¸¤ç§ bodyï¼š
	è¡¨è¾¾å¼ä½“ï¼š() -> expr
	è¯­å¥å—ä½“ï¼š() -> { statements }
return; æ˜¯ statementï¼Œä¸æ˜¯ expressionï¼ˆlambdaè¡¨è¾¾å¼ï¼‰ã€‚

10.Was bedeutet der Ausdruck "(x, y) -> x + y" in einem Lambda-Ausdruck?
a.Ein Lambda-Ausdruck, der nur den Wert x zurÃ¼ckgibt, und y wird nach der RÃ¼ckgabe des Lambda-Ausdrucks addiert
b.Eine Methode, die eine Summe als arithmetischen Ausdruck zurÃ¼ckgibt
c.Eine Funktion, die zwei Parameter empfÃ¤ngt und deren Konkatenation zurÃ¼ckgibtâœ…â“ä¸ºä»€ä¹ˆKontatenationä¹Ÿå¯¹ï¼Œè¿™é‡ŒæŒ‡çš„æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥
å› ä¸ºåœ¨ Java ä¸­ï¼Œx + y çš„å«ä¹‰å–å†³äº x å’Œ y çš„ç±»å‹ï¼šâ€¼ï¸
å®ƒæ—¢å¯èƒ½æ˜¯â€œæ•°å€¼æ±‚å’Œâ€ï¼Œä¹Ÿå¯èƒ½æ˜¯â€œå­—ç¬¦ä¸²æ‹¼æ¥ï¼ˆKonkatenationï¼‰â€ã€‚
è€Œ Lambda è¡¨è¾¾å¼ (x, y) -> x + y æœ¬èº«å¹¶æ²¡æœ‰ç±»å‹ï¼Œ
æ‰€ä»¥è¿™ä¸¤ç§è§£é‡Šåœ¨è¯­ä¹‰ä¸Šéƒ½æ˜¯æˆç«‹çš„ã€‚
d.Eine Funktion, die zwei Parameter empfÃ¤ngt und deren Summe zurÃ¼ckgibtâœ…

13.å¦‚ä½•åˆ¤æ–­ä¸€æ®µä»£ç æ˜¯å¦kompilierbar
1ï¸âƒ£æ˜¯å¦æœ‰å‡½æ•°å¼æ¥å£
2ï¸âƒ£Lambda å‚æ•°èƒ½å¦è¢«ä¿®æ”¹ï¼Ÿ
3ï¸âƒ£Lambda å‚æ•°èƒ½å¦è¢«ä¿®æ”¹ï¼Ÿ
4ï¸âƒ£å¦‚æœå‡½æ•°å¼æ¥å£çš„æ–¹æ³•æœ‰è¿”å›å€¼ï¼Œblock lambda å¿…é¡»åœ¨æ‰€æœ‰è·¯å¾„ä¸Š return ä¸€ä¸ªå€¼

15.In welchem Szenario ist ein Lambda-Ausdruck in Java am nÃ¼tzlichsten?
a.Bei der Verarbeitung von Daten in Streamsâœ…Java é‡Œçš„ Lambda æœ€æœ‰ä»·å€¼ã€æœ€å…¸å‹ã€æœ€æ ¸å¿ƒçš„ç”¨é€”ï¼šå°±æ˜¯ç»™ Stream API æä¾›â€œâ€¼ï¸è¡Œä¸ºå‚æ•°â€ï¼ˆFunction / Predicate / Consumerï¼‰ã€‚
b.Beim Erstellen von benutzerdefinierten Datentypen
c.Wenn Werte aus einer Datenbank geladen werden
d.Wenn Methoden mit vielen Parameterwerten aufgerufen werden mÃ¼ssen
â€¼ï¸Lambda åœ¨ Java ä¸­æœ€æœ‰ç”¨çš„åœºæ™¯æ˜¯ï¼ŸStream / filter / map / forEach










Codefragenè®¢æ­£ï¼š

1.
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

Welcher Lambda-Ausdruck kann dieses Interface implementieren ?
a.(Integer a, Integer b) -> { a + b }âŒ é‡ç‚¹åœ¨è¿™ä¸ª{} è¿™æ˜¯ä¸€ä¸ªä»£ç å—ï¼Œä»£ç å—lambdaä¸ä¼šè‡ªåŠ¨returnâ€¼ï¸
b.(Integer a, Integer b) -> { return a + b; }âœ…å‚æ•°ç±»å‹å¯ä»¥é è‡ªåŠ¨æ‹†ç®±(unboxing)å…œåº•
c.(a, b) -> a + bâœ…è¡¨è¾¾å¼lambda ->è‡ªåŠ¨return

å‚æ•°ç±»å‹çš„æ¨æ–­æ¥è‡ªå‡½æ•°å¼æ¥å£çš„æ–¹æ³•ç­¾åï¼Œæ‰€ä»¥åªè¦æ¥å£æœ‰å¥½å¥½å†™æ˜ç™½å°±å¯ä»¥è‡ªåŠ¨æ¨æ–­å‡ºæ¥ç±»å‹ã€‚

â€¼ï¸çœ‹åˆ° lambda ç›´æ¥é—®è‡ªå·±ä¸‰ä»¶äº‹ï¼š
æœ‰æ²¡æœ‰ {}ï¼Ÿ			æœ‰ â†’ å¿…é¡»æ‰‹åŠ¨ return
å‚æ•°ç±»å‹èƒ½ä¸èƒ½æ¨æ–­ï¼Ÿ	èƒ½ â†’ (a, b) æ°¸è¿œæœ€å®‰å…¨
è¿”å›å€¼æœ€ç»ˆç±»å‹å¯¹ä¸å¯¹ï¼Ÿ	çœ‹â€œç®—å®Œä¹‹åâ€ï¼Œä¸æ˜¯çœ‹å‚æ•°


2.
List<String> names = List.of("Alice", "FOPBob", "Charlie");
Welcher Ausdruck gibt jeden Namen aus?

a.names.forEach(System.out::println);âœ…
b.names.forEach(name -> { System.out.println(name) });âŒ
c.names.forEach(name -> System.out.println(name));âœ…


â€¼ï¸forEach(Consumer<? super T>)
Consumer<? super T> çš„æ„æ€æ˜¯ï¼šç»™æˆ‘ä¸€ä¸ªâ€œè‡³å°‘èƒ½æ¥æ”¶ Tâ€çš„ Consumerï¼Œæˆ‘ä¼šæŠŠ T äº¤ç»™å®ƒç”¨ã€‚
Consumer<T>
Methode: void accept(T t)	Verbraucht einen Wert T, fÃ¼hrt eine Aktion aus, gibt aber nichts zurÃ¼ck


çœ‹åˆ° lambdaï¼Œå…ˆé—® æ¥å£æ–¹æ³•è¿”å›ä»€ä¹ˆï¼š
	â€¢	è¿”å› void
â†’ ä¸ç®¡æœ‰æ²¡æœ‰ {}ï¼Œéƒ½ä¸éœ€è¦ return
	â€¢	è¿”å›é void
â†’ æœ‰ {} å°±å¿…é¡» return


æ˜¯å¦éœ€è¦ returnï¼Œåªå–å†³äºæ¥å£æ–¹æ³•çš„è¿”å›ç±»å‹ï¼Œå’Œæœ‰æ²¡æœ‰ {} æ²¡æœ‰æœ¬è´¨å…³ç³»ã€‚


4.Javaé‡Œå­—ç¬¦ä¸²å¦‚ä½•æ¯”è¾ƒï¼šString.compareTo(String)

ä»å·¦åˆ°å³ï¼Œä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦æ¯”ï¼Œç”¨å­—ç¬¦çš„ Unicode å€¼ æ¯”å¤§å°

è¿”å›å€¼çš„æ„ä¹‰ï¼š
è¿”å›è´Ÿæ•° â†’ a æ’åœ¨ b å‰
è¿”å› 0 â†’ ä¸¤ä¸ªå­—ç¬¦ä¸²åœ¨â€œæ’åºæ„ä¹‰ä¸Šç›¸ç­‰â€
è¿”å›æ­£æ•° â†’ a æ’åœ¨ b å

ä½†â€œå‰ / åâ€çš„ä¾æ®æ˜¯ï¼šå­—å…¸åºï¼ˆlexicographical orderï¼‰ã€‚

ğŸŒ°1:
BiFunction<String, String, Integer> compare = String::compareTo;
int result = compare.apply("apple", "pen");
Aï¼šè¿”å›-1

ğŸŒ°2:
"apple".compareTo("banana")   // < 0  ('a' < 'b')
"app".compareTo("apple")      // < 0  (å‰ç¼€æ›´çŸ­ â†’ æ›´å°)
"Zoo".compareTo("apple")      // < 0  ('Z' < 'a')	âš ï¸å¤§å†™å­—æ¯ < å°å†™å­—æ¯ï¼ˆUnicode å†³å®šçš„ï¼‰











Recap7 1ğŸˆ·ï¸19æ—¥
Thema 7 - Fehlerbehandlung


1ï¸âƒ£Exceptionçš„ä¸¤ç§ç±»å‹ï¼šåŒºåˆ«åœ¨äºç¼–è¯‘å™¨æ˜¯å¦å¼ºåˆ¶ä½ å¤„ç†
checkedï¼šç»§æ‰¿è‡ª Exceptionï¼Œä½†ä¸æ˜¯ RuntimeException	â€”â€”>	 å¿…é¡»åœ¨ç¼–è¯‘æœŸå¤„ç†
ğŸŒ°ï¼šIOExceptionï¼ŒSQLException
uncheckedï¼šç»§æ‰¿è‡ª RuntimeException   â€”â€”>	 ç¼–è¯‘å™¨ä¸å¼ºåˆ¶å¤„ç†
ğŸŒ°ï¼šNullPointerExceptionï¼ŒArithmeticExceptionï¼Œ IndexOutOfBoundsException


2ï¸âƒ£
RuntimeException(é€»è¾‘é”™è¯¯)å¯ä»¥é€šè¿‡æ›´å¥½çš„ä»£ç é¿å…
ğŸŒ°ï¼šNullPointerException, IllegalArgumentException, IndexOutOfBoundsException.

Error(âŒç³»ç»Ÿå­˜åœ¨ä¸¥é‡é—®é¢˜ï¼Œä¸æ˜¯æ­£å¸¸é”™è¯¯å¤„ç†çš„ä¸€éƒ¨åˆ†)
ğŸŒ°ï¼šOutOfMemoryErrorï¼ŒStackOverflowError

3ï¸âƒ£try-catch-finally
tryï¼š// å¯èƒ½æŠ›å¼‚å¸¸çš„æœ€å°ä»£ç å—ï¼ˆä½†ä¸ä¸€å®šæŠ›ï¼‰ï¼Œtry ä¸æ˜¯â€œä¸€å®šä¼šå‡ºé”™â€ï¼Œåªæ˜¯â€œå…è®¸å‡ºé”™â€ï¼Œæœ€å¯èƒ½å‡ºé”™çš„ä»£ç å—éƒ¨åˆ†
catchï¼š// åªèƒ½æ•è· try å—ä¸­æŠ›å‡ºçš„ã€å¹¶ä¸”â€¼ï¸ç±»å‹åŒ¹é…çš„å¼‚å¸¸ã€‚
finallyï¼š// ä¸€å®šæ‰§è¡Œï¼ˆå‡ ä¹ï¼‰
âš ï¸å”¯ä¸€å‡ ä¸ªä¾‹å¤–ï¼šSystem.exit(...) / JVM ç›´æ¥å´©æºƒ

try -> æ­£å¸¸ -> finally
	-> æŠ¥é”™ -> catchï¼ˆä¸ç®¡caæ²¡caåˆ°ï¼‰	-> finally

try æŠ›å¼‚å¸¸
â†’ æ‰€æœ‰ catch å°è¯•åŒ¹é…ï¼ˆå¤±è´¥ï¼‰
â†’ æ‰§è¡Œ finally
â†’ å¼‚å¸¸å‘å¤–æŠ›ï¼ˆå½“å‰æ–¹æ³•ç›´æ¥ç»“æŸï¼‰

4ï¸âƒ£catchå†…éƒ¨çš„Exceptioné¡ºåºè‡³å…³é‡è¦â€¼ï¸
é¦–å…ˆå¿…é¡»å¤„ç†ç‰¹å®šçš„ä¾‹å¤–ç±»ï¼Œç„¶åæ˜¯ä¸€èˆ¬ä¾‹å¤–ã€‚æˆ–è€…å­ç±»æ’åœ¨å‰é¢ï¼Œçˆ¶ç±»æ’åœ¨åï¼ˆå¦åˆ™é—®é¢˜çš„å…·ä½“æè¿°ä¼šå› æ³›åŒ–è€Œä¸¢å¤±ï¼‰ã€‚
â“é‚£ä¸ºä»€ä¹ˆä¸ç›´æ¥å†™çˆ¶ç±»ï¼Œå­ç±»åæ­£ä¹ŸåŒ…å«è¿›å»äº†ï¼Ÿ
Aï¼šè¿™é‡Œçš„æ„æ€æ˜¯ï¼Œå¦‚æœæœ‰ å¤šä¸ªcatchå¹¶ä¸”å­˜åœ¨ç»§æ‰¿å…³ç³»çš„è¯ï¼Œé‚£ä¹ˆéœ€è¦æŒ‰ç…§å­ç±»åœ¨å‰çˆ¶ç±»åœ¨åçš„é¡ºåºæ¥å†™ã€‚

try {
// ...
} catch (IOException e) {
	// IO Fehler
} catch (NullPointerException e) {
	// Null-Fehler
}

é‚£ä¹ˆå“ªäº›æ˜¯ç‰¹å®šå“ªäº›æ˜¯ä¸€èˆ¬ä¾‹å¤–å‘¢ï¼Ÿ
çœ‹ç»§æ‰¿å…³ç³»ï¼Œçˆ¶ç±»æ˜¯ä¸€èˆ¬ä¾‹å¤–ï¼Œå­ç±»æ˜¯ç‰¹å®šä¾‹å¤–
â€¢Throwable
	â€¢Exception
	   â€¢RuntimeException
			â€¢NullPointerException
			â€¢IllegalArgumentException

5ï¸âƒ£multi-catch
try {
	// ...
} catch (IOException | SQLException e) {
	e.printStackTrace();â€¼ï¸è¿™å«ç›¸åŒçš„å¤„ç†é€»è¾‘
}
é€‚ç”¨æƒ…å†µï¼šç›¸åŒçš„å¤„ç†é€»è¾‘å¹¶ä¸”â€¼ï¸æ²¡æœ‰ç»§æ‰¿å…³ç³»çš„è¯

6ï¸âƒ£
public class MyException extends Exception {
	public MyException(String message) {
		super(message);
	}
}
è¿™é‡Œsuper(message)çš„ä½œç”¨ï¼Ÿ
ç”±äºå­ç±»å¯¹è±¡ä¸­åŒ…å«çˆ¶ç±»çš„çŠ¶æ€ï¼Œåœ¨æ„é€ å­ç±»å¯¹è±¡æ—¶å¿…é¡»å…ˆè°ƒç”¨çˆ¶ç±»æ„é€ å™¨ï¼Œä»¥ä¾¿ç”±çˆ¶ç±»è‡ªèº«å®Œæˆå…¶éƒ¨åˆ†çš„åˆå§‹åŒ–ï¼›å› æ­¤åœ¨è‡ªå®šä¹‰å¼‚å¸¸ä¸­é€šè¿‡ super(message) å°†å‚æ•°ä¼ é€’ç»™çˆ¶ç±»æ„é€ å™¨ã€‚

7ï¸âƒ£throwå’Œthrows
throwï¼šæŠ›å‡ºå¼‚å¸¸
throwsï¼šå£°æ˜å¯ä»¥æŠ›å‡ºå¼‚å¸¸

public void checkAge(int age) throwsâ€¼ï¸ IllegalArgumentException {
	if (age < 18) {
		throwâ€¼ï¸ new IllegalArgumentException("Zu jung!");
	}
}

8ï¸âƒ£å¸¸è§è¯¯åŒº
1.finally funktioniert Ã¤hnlich wie else und wird nur ausgefÃ¼hrt, wenn keine Exception geworfen wurde.âŒ
finallyæ˜¯ä¸ç®¡æ€ä¹ˆæ ·éƒ½ä¼šæ‰§è¡Œçš„

2.Alle Exceptions mÃ¼ssen behandelt werden.âŒ
åªæœ‰ checked exceptionï¼ˆå—æ£€å¼‚å¸¸ï¼‰æ‰â€œå¿…é¡»å¤„ç†æˆ–å£°æ˜â€
unchecked exceptionï¼ˆRuntimeException åŠå…¶å­ç±»ï¼‰å¯ä»¥ä¸å¤„ç†

â€¼ï¸3.catch(Exception e) ist eine universelle LÃ¶sung.âŒ
universellåœ¨å¯ä»¥å…¨éƒ¨æ¥ä½ï¼Œä½†æ˜¯å¹¶ä¸èƒ½å…¨éƒ¨è§£å†³ï¼Œå› ä¸ºå…·ä½“å¼‚å¸¸å…·ä½“åˆ†æï¼Œä¸å¯èƒ½æœ‰ä¸‡èƒ½è§£èƒ½è§£å†³æ‰€æœ‰ç±»å‹çš„å¼‚å¸¸

4.finally ist nicht notwendig, wenn einer der catch-BlÃ¶cke garantiert ausgefÃ¼hrt wird.âŒ
catch ä¸æ˜¯ä¿è¯æ‰§è¡Œçš„
finally æ‰æ˜¯å”¯ä¸€çš„â€œæ¸…ç†ä¿è¯â€

5.Error sei eine Unterklasse oder eine Oberklasse von Exception.âŒ
Errorå’ŒExceptionæ˜¯Throwableçš„å­ç±»ï¼Œä»–ä¿©å¹³è¡Œ

6.In jedem catch-Block muss die Variable anders heiÃŸen, um Compilerfehler zu vermeiden.âŒ
éƒ½å¯ä»¥å«eæ²¡å…³ç³»
try { ... }
catch (IOException e) { ... }
catch (SQLException e) { ... } // âœ” å®Œå…¨åˆæ³•

7.Man kann in multi-catch beliebige Klassen zusammen kombinieren.âŒ
å¿…é¡»æ˜¯å¤„ç†é€»è¾‘å®Œå…¨ç›¸åŒå¹¶ä¸”æ²¡æœ‰ç»§æ‰¿å…³ç³»çš„å¼‚å¸¸ç±»å‹







Theoriefragenè®¢æ­£ï¼š
1.Warum schreiben wir die ganze Klasse oder den gesamten Code in try-catch-BlÃ¶cke nicht?
a.Doch, es ist mÃ¶glich und ist eine gute PraxisâŒ
b.Verstecken von Fehlern - unerwartete Fehler werden ignoriertâœ…âš ï¸
å› ä¸ºï¼
try {
    // æ•´ä¸ªç¨‹åº
}
catch (Exception e) {
    // ä»€ä¹ˆéƒ½ä¸åš / åªæ‰“å°ä¸€å¥
}
ç»“æœæ˜¯ï¼š
	â€¢	æœ¬æ¥åº”è¯¥æš´éœ²çš„ bug
	â€¢	è¢«ä½  catch æ‰äº†
	â€¢	ç¨‹åºâ€œå‡è£…è¿˜èƒ½è·‘â€â€¼ï¸
ğŸ‘‰ è¿™å°±å«â€œé”™è¯¯è¢«éšè—â€
c.Unklare Fehlerbehandlung - es wird schwierig zu erkennen, welcher Teil des Codes Fehler verursacht hatâœ…
d.Verschlechterte Performance (Leistung) von Programmâœ…

2.Worin besteht der Unterschied zwischen checked und unchecked Exceptions in Java?
a.Checked Exceptions mÃ¼ssen entweder mit try/catch behandelt oder im Methodenkopf mit throws deklariert werden. 
Unchecked Excpetions kann man vorhersagen, darum mÃ¼ssen sie auch nicht behandelt werden.âœ…
b.Beide Arten von Exceptions mÃ¼ssen mithilfe der throws-Clause behandelt werden, 
aber eine checked Excpetion wirft man selbst mit "throw", und die unchecked Exceptions wird Java bei Bedarf selbst werfen.âŒä¸¤ç§å¼‚å¸¸éƒ½èƒ½æ‰‹åŠ¨werfenæˆ–è€…Java bei Bedarf selbst werfen
âš ï¸Checked Exceptions å¿…é¡»åœ¨ç¼–è¯‘æœŸé€šè¿‡ try/catch æˆ– throws å¤„ç†ï¼›
Unchecked Exceptions ä¸å—ç¼–è¯‘å™¨å¼ºåˆ¶ã€‚
Checked Exceptions é€šå¸¸è¡¨ç¤ºå¯æ¢å¤çš„å¤–éƒ¨é”™è¯¯ï¼Œ
è€Œ RuntimeExceptions å¤šä¸ºç¼–ç¨‹é”™è¯¯ã€‚
c.Checked Excpetions geben wiederherstellbare Fehler/ ZustÃ¤nde des Programms wieder, 
wÃ¤hrend RuntimeExceptions eher Programmierfehler sind, die manchmal schwer nachvolziehbar sind.âœ…

3.Was passiert, wenn eine Exception in einem try-Block geworfen wird, aber kein passender catch-Block vorhanden ist?
a.Falls vorhanden, wird der finally-Block ausgefÃ¼hrt.âœ…
b.Die Exception wird weitergegeben (propagiert), und das Programm kann abstÃ¼rzen, wenn sie nicht abgefangen wird.âœ…finallyçš„æ‰§è¡Œå’Œç¨‹åºå æ¯ä¸çŸ›ç›¾ã€‚
c.Die Exception wird ignoriert, und das Programm lÃ¤uft normal weiter.âŒ





Codefragenè®¢æ­£ï¼š
1.åœ¨throwsï¼ˆå£°æ˜ï¼‰çš„æ—¶å€™å¯ä»¥ç›´æ¥å†™çˆ¶ç±»è€Œä¸æ˜¯è¯¦ç»†åœ°å†™åˆ°å­ç±»

2.åç¼€è‡ªå¢x++çš„æ„æ€æ˜¯ï¼š
å…ˆä½¿ç”¨â€œæ—§å€¼â€ï¼Œå†æŠŠå˜é‡åŠ  1

å†™æ³•			æ‰§è¡Œé¡ºåº			è¡¨è¾¾å¼çš„å€¼		å˜é‡æœ€ç»ˆå€¼	
++x			å…ˆåŠ  1ï¼Œå†ç”¨		æ–°å€¼				æ–°å€¼				
x++			å…ˆç”¨ï¼Œå†åŠ  1		æ—§å€¼				æ–°å€¼

3.
try{
    sample();
}
catch (FileNotFoundException e) { ... }
catch (NoSuchMethodException e) { ... }
catch (NullPointerException e) { ... }

åœ¨multi-catchçš„æ—¶å€™ï¼Œä½¿ç”¨åŒä¸ªå˜é‡eæ˜¯okçš„ï¼›
å˜é‡æ²¡æœ‰ç»§æ‰¿å…³ç³»æ‰€ä»¥é¡ºåºæ²¡å…³ç³»







Recap8 1ğŸˆ·ï¸21æ—¥
Thema 8 - Generics

1.Genericsæœ¬è´¨ï¼šEin Algorithmus fuer mehreren Typen.
Generics åªå­˜åœ¨äºç¼–è¯‘æœŸï¼Œè¿è¡ŒæœŸä¼šè¢«â€œæ“¦é™¤â€ï¼ˆType Erasureï¼‰ 
Generics å°±æ˜¯ï¼šç»™ç›’å­è´´æ ‡ç­¾ã€‚
âœ…
Box<è‹¹æœ> box = new Box<>();		æ„æ€æ˜¯ï¼šè¿™ä¸ªç®±å­ï¼Œåªå…è®¸æ”¾è‹¹æœ
box.put(è‹¹æœ);   // âœ…
box.put(é‹å­);   // âŒ è€å¸ˆç«‹åˆ»æ‹¦ä½ä½ ï¼Œé”™è¯¯å½“åœºæŠ“ä½ï¼Œè¿™å°±æ˜¯ Genericsã€‚

âŒæ²¡æœ‰ Generics çš„ä¸–ç•Œï¼ˆæ²¡è´´æ ‡ç­¾ï¼‰
æƒ³è±¡ä¸€ä¸ªç®±å­ã€‚
Box box = new Box();
box.put(ä¸œè¥¿);
è¿™ä¸ªç®±å­ï¼š
	â€¢	è°éƒ½èƒ½å¾€é‡Œå¡
	â€¢	è‹¹æœã€é‹å­ã€é’¥åŒ™éƒ½è¡Œ
	â€¢	ç®±å­ä¸ç®¡ä½ å¡ä»€ä¹ˆ
ç»“æœä¼šæ€æ ·ï¼ŸğŸ‘‰ æ‹¿çš„æ—¶å€™æ‰å‘ç°æ‹¿é”™äº†
ç°åœ¨æ²¡é—®é¢˜ï¼Œä»¥åä¸€å®šå‡ºäº‹

âœ…å¯¹åº”åˆ° Java
List<String> list = new ArrayList<>();
æˆ‘æœ‰ä¸€ä¸ªâ€œåå•â€ï¼Œ
è¿™ä¸ªåå•åªå…è®¸å†™å­—ç¬¦ä¸²åå­—

å¾€é‡Œæ”¾ä¸œè¥¿ï¼š
list.add("å°æ˜");   // âœ…
list.add(123);     // âŒ è€å¸ˆæ‘‡å¤´
ä½ ç”šè‡³è¿˜æ²¡â€œè¿è¡Œâ€ï¼Œè€å¸ˆï¼ˆç¼–è¯‘å™¨ï¼‰å·²ç»è¯´ï¼šğŸ‘‰ ä¸è¡Œ
â€¼ï¸å¯¹åº”Genericsçš„æœ¬è´¨ï¼šåªå­˜åœ¨äºç¼–è¯‘æœŸï¼Œè¿è¡ŒæœŸä¼šè¢«æ“¦é™¤

æ‹¿ä¸œè¥¿ï¼š
String name = list.get(0);
æˆ‘çŸ¥é“è¿™é‡Œé¢ä¸€å®šæ˜¯â€œåå­—â€ï¼Œ
ä¸ç”¨æ£€æŸ¥ï¼Œä¸ä¼šæ‹¿é”™


2.æ³›å‹ç±»
class Box<T> {
    T value;
}

ä½ åªéœ€è¦è®°ä¸€å¥è¯ï¼šğŸ‘‰ T å°±æ˜¯â€œå ä½ç¬¦â€
åƒè¿™æ ·ç†è§£ï¼š
class Box<è¿™é‡Œä»¥åå†è¯´æ˜¯ä»€ä¹ˆâ€¼ï¸> {
    è¿™é‡Œä»¥åå†è¯´æ˜¯ä»€ä¹ˆ value;
}

çœŸæ­£ä½¿ç”¨çš„æ—¶å€™æ‰å†³å®š
Box<è‹¹æœ> a = new Box<>();
Box<é¦™è•‰> b = new Box<>();
aï¼šåªèƒ½æ”¾è‹¹æœ
bï¼šåªèƒ½æ”¾é¦™è•‰
ğŸ‘‰ åŒä¸€ä¸ªç›’å­æ¨¡å…·ï¼Œä¸åŒæ ‡ç­¾



3. æ³›å‹æ–¹æ³•
public static <T> T getFirst(T[] arr)
getFirstï¼šæ–¹æ³•å
Tï¼šè¿”å›ç±»å‹ï¼Œå ä½ç¬¦ï¼Œä¸€ä¸ªç±»å‹çš„åå­—ï¼Œâ€œéšä¾¿ä»€ä¹ˆç±»å‹ï¼Œä½†æˆ‘å…ˆç»™å®ƒèµ·ä¸ªåå­—å« Tâ€
<T>:è¿™ä¸€å¥æ˜¯å£°æ˜ï¼šæ„æ€æ˜¯ï¼Œæ¥ä¸‹æ¥è¿™ä¸ªæ–¹æ³•é‡Œæˆ‘ä¼šç”¨åˆ°ä¸€ä¸ªâ€œâ€¼ï¸ç±»å‹å˜é‡â€ï¼Œå®ƒå« T

æˆ‘å†™äº†ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒä¸å…³å¿ƒä½ ç»™æˆ‘ä»€ä¹ˆç±»å‹ï¼Œä½ ç»™æˆ‘ä»€ä¹ˆç±»å‹ï¼Œæˆ‘å°±åŸæ ·è¿˜ä½ ä¸€ä¸ªâ€¼ï¸è€Œè¿™ä¸ªç±»å‹æˆ‘ä¸´æ—¶å«å®ƒ T

ä¹Ÿå°±æ˜¯è¯´â€¼ï¸è¿™ä¸ªæ³›å‹æ–¹æ³•ä¹Ÿå°±æ˜¯æ™®é€šçš„æ–¹æ³•ä¸Šå£°æ˜äº†ä¸€ä¸ªç±»å‹å˜é‡ï¼Œå…¶å®ƒè·Ÿæ™®é€šæ–¹æ³•ä¸€æ¨¡ä¸€æ ·


4.<?>
List<?> list;
æˆ‘ä¸çŸ¥é“ç›’å­é‡Œè£…çš„æ˜¯ä»€ä¹ˆï¼Œæ‰€ä»¥â€”â€”ä¸æ•¢å¾€é‡Œæ”¾ä»»ä½•ä¸œè¥¿
ä½†ï¼š
	â€¢	ğŸ‘€ å¯ä»¥çœ‹çœ‹â€¼ï¸
	â€¢	âœ‹ ä¸æ•¢ä¹±å¡â€¼ï¸

æ€»ç»“ï¼š
1ï¸âƒ£ Generics = ç»™å®¹å™¨è´´æ ‡ç­¾
2ï¸âƒ£ æœ‰æ ‡ç­¾ â†’ æ”¾é”™ä¸œè¥¿å½“åœºè¢«æ‹¦
3ï¸âƒ£ T = ä»¥åå†å†³å®šæ˜¯ä»€ä¹ˆçš„å ä½ç¬¦
4ï¸âƒ£ <?> = æˆ‘ä¸çŸ¥é“æ˜¯ä»€ä¹ˆï¼Œæ‰€ä»¥ä¸æ•¢ä¹±åŠ¨


Folienï¼š
1.Genericsä½¿å¾—ç±»ã€æ¥å£ã€æ–¹æ³•å¾—ä»¥ä½œä¸ºå˜é‡
2.ä½¿ç”¨æ³›å‹ç±»å‹ï¼ˆå˜é‡ / å‚æ•° / è¿”å›å€¼ï¼‰
ğŸ“ä½ç½®ï¼šList<...>ã€Map<...> é‡Œ
è¿™é‡Œæ‰ä¼šå‡ºç°ï¼š? extends å’Œ ? super

? extends Numberï¼šæˆ‘ä¸çŸ¥é“å…·ä½“æ˜¯å“ªä¸€ç§ï¼Œä½†å®ƒä¸€å®šæ˜¯ Number çš„å­©å­  	â€”â€”â€”â€”>é€‚åˆè¯»â“å› ä¸ºå·²çŸ¥æ˜¯Numberçš„å­ç±»ï¼Œå¯èƒ½æ˜¯Integerã€Doubleã€Longï¼Œå¯ä»¥è¯»ï¼Œä½†æ˜¯å¦‚æœå†™List.add(1)ï¼Œä¸‡ä¸€é‡Œé¢æ˜¯doubleè¿™ä¸ç‚¸äº†å—
? super Stringï¼šæˆ‘ä¸çŸ¥é“å…·ä½“æ˜¯å“ªä¸€ç§ï¼Œä½†å®ƒä¸€å®šæ˜¯ String çš„çˆ¸çˆ¸æˆ–ç¥–å…ˆ   â€”â€”â€”â€”>é€‚åˆå†™â“å› ä¸ºå·²çŸ¥æ˜¯Stringçš„çˆ¶ç±»ï¼Œå¯èƒ½æ˜¯Stringã€Objectâ€¼ï¸ï¼Œå¯ä»¥å†™List.add("Hello")ä¸ç®¡æ˜¯å“ªä¸ªç±»å‹éƒ½èƒ½æ”¾è¿›å»

3.å®ç°çš„æ—¶å€™ æ³›å‹æ¥å£ / ç±»æ—¶ï¼Œåªæœ‰ä¸¤ä¸ªé€‰æ‹©ï¼š
1ï¸âƒ£ ç»§ç»­å½“â€œå¯å˜çš„ç›’å­â€ï¼ˆä¿ç•™æ³›å‹ï¼‰		class MyBox<T> implements Boxable<T> { ... }
2ï¸âƒ£ å˜æˆâ€œä¸“ç”¨ç›’å­â€ï¼ˆå›ºå®šæˆæŸä¸€ç§ç±»å‹ï¼‰	class StringBox implements Boxable<String> { ... }
â€¼ï¸implements Boxable<?>æ‰€ä»¥æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºåªæœ‰è¿™ä¸¤ç§é€‰æ‹©

âš ï¸
1ï¸âƒ£Typparameter weiterreichenå¦‚æœæ¥å£æ˜¯æ³›å‹çš„ï¼Œç±»ä¹Ÿå¯ä»¥ç»§ç»­æ˜¯æ³›å‹çš„
2ï¸âƒ£Konkreter Typä¸€æ—¦ä½ åœ¨ implements é‡Œå†™äº†å…·ä½“ç±»å‹ï¼Œå°±å®šæ­»äº†
class StringBox implements Boxable<String> { }
3ï¸âƒ£æ¥å£ / çˆ¶ç±»æœ‰â€œé™åˆ¶â€ï¼Œä½ ä¸èƒ½æ— è§†
interface Boxable<T extends Number> { } â€¼ï¸è¿™é‡Œçš„æ¥å£æœ‰<T extends Number>
class MyBox<T extends Number> implements Boxable<T> { } â€¼ï¸é‚£ä¹ˆå®ç°çš„ç±»ä¹Ÿå¿…é¡»æœ‰<T extends Number>
ğŸŒ°ï¼š
interface I<T> { }
class A implements I<?> { }   // âŒ
<T>ï¼š â€œæˆ‘éœ€è¦ä¸€ä¸ªå¯è¿½è¸ªçš„ç±»å‹èº«ä»½â€
<?>ï¼š â€œæˆ‘ä¸å…³å¿ƒä½ æ˜¯è°ï¼Œåªè¦æˆ‘å®‰å…¨ç”¨â€

è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆï¼š<T> å¯ä»¥ç”¨äºå£°æ˜ï¼Œ? åªèƒ½ç”¨äºä½¿ç”¨

4.<? super T> å’Œ <? extends T> 
<? super T> : Tæˆ–Tçš„çˆ¶ç±»
T = String
é‚£ä¹ˆï¼Ÿå¯èƒ½æ˜¯ï¼šStringã€Objectï¼ˆä»¥åŠ String çš„å…¶ä»–çˆ¶ç±» / æ¥å£ï¼‰

<? extends T> : Tæˆ–Tçš„å­ç±»
T = Number
List<Integer> 
List<Double> 
List<Number> 
ğŸ‘‰ éƒ½æ˜¯ Number æˆ–å­ç±»
è¯»ok å†™ä¸ok

5.Type Erasure
Java çš„æ³›å‹åªç»™ç¼–è¯‘å™¨çœ‹ï¼Œè¿è¡ŒæœŸä¼šè¢«æ“¦é™¤â€¼ï¸
1ï¸âƒ£æ²¡æœ‰ boundï¼š{T -> Object}
class Box<T> {    â¡ï¸	class Box {
    T value;		    	Object value;
}						}

2ï¸âƒ£æœ‰ upper boundï¼š{T â€”> upper bound}
class Box<T extends Number> {		â¡ï¸		class Box {
    T value;									Number value;
}											}												

âš ï¸ï¼šæ‰€ä»¥
1ï¸âƒ£instanceof æ³›å‹ä¸å­˜åœ¨ï¼š
if (list instanceof List<String>) { } // âŒ
å› ä¸ºè¿è¡Œçš„æ—¶å€™æ³›å‹ä¼šè¢«æ“¦æ‰ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘å™¨å®é™…çœ‹åˆ°ï¼š
list instanceof List æ ¹æœ¬çœ‹ä¸åˆ°<>é‡Œé¢çš„ç±»å‹
2ï¸âƒ£æ³›å‹æ•°ç»„ä¸å­˜åœ¨ï¼š
æ•°ç»„ï¼šè¿è¡Œæ—¶è¦çŸ¥é“å…ƒç´ ç±»å‹ï¼›
æ³›å‹ï¼šè¿è¡Œæ—¶ç±»å‹è¢«æ“¦æ‰
ğŸ‘‰ ä¸€ä¸ªè¦â€œçŸ¥é“â€ï¼Œä¸€ä¸ªâ€œä¸çŸ¥é“â€ï¼Œå¤©ç”Ÿå†²çª
3ï¸âƒ£ä¸èƒ½åªé æ³›å‹æ¥é‡è½½æ–¹æ³•
void print(List<String> list) { }
void print(List<Integer> list) { } // âŒ
æ“¦é™¤åå˜æˆï¼š
void print(List list)
void print(List list)

6.å¸¸è§è¯¯åŒºFehlvorstellung
1ï¸âƒ£Genericså’Œprimitiveç±»å‹ä¸èƒ½æ”¾åœ¨ä¸€èµ·ï¼Œ
å› ä¸ºæ³›å‹çš„æœ¬è´¨æ˜¯ ç¼–è¯‘æœŸæ£€æŸ¥ï¼Œè¿è¡ŒæœŸâ€¼ï¸ æ“¦é™¤ä¸º Object / Bound
è€Œprimitiveï¼ˆint, double, booleanâ€¦ï¼‰ä¸æ˜¯ Objectã€‚
2ï¸âƒ£ä¸èƒ½åˆ›å»ºæ³›å‹æ•°ç»„
T[] arr = new T[10];   // âŒ
List<String>[] arr = new List<String>[10]; // âŒ
List<T> list = new ArrayList<>();âœ…
å‡¡æ˜¯ new T[...]ï¼Œä¸€å®šæ˜¯é”™çš„â€¼ï¸
3ï¸âƒ£? extends T = æˆ‘å¯ä»¥éšä¾¿ç”¨ T çš„å­ç±»âŒ
äº‹å®æ˜¯ï¼šå“ªä¸ªéƒ½ä¸æ•¢ç”¨ï¼Œå› ä¸ºæ ¹æœ¬ä¸ç¡®å®š
â€¼ï¸åªèƒ½è¯»ä¸èƒ½å†™
4ï¸âƒ£è¿è¡Œæ—¶å¯ä»¥æ£€æŸ¥æ³›å‹ç±»å‹ï¼ˆinstanceofï¼‰âŒ
if (list instanceof List<String>) { } // âŒ
if (list instanceof List) { } // âœ…
instanceof åªèƒ½çœ‹åˆ°â€œæ“¦é™¤åçš„ç±»å‹â€
5ï¸âƒ£æ³›å‹æ–¹æ³•åªèƒ½å†™åœ¨æ³›å‹ç±»é‡ŒâŒ
class Util {
    public static <T> T first(T[] arr) {
        return arr[0];
    }
}
æ³›å‹ç±»å’Œæ–¹æ³•æ²¡æœ‰ä»»ä½•å…³ç³»



â€¼ï¸â€¼ï¸ä½ ç°åœ¨åº”è¯¥å½¢æˆçš„â€œæ¡ä»¶åå°„â€
çœ‹åˆ°ä»£ç ï¼Œè„‘å­é‡Œç«‹åˆ»é—®ï¼š
1.	è¿™æ˜¯å£°æ˜è¿˜æ˜¯ä½¿ç”¨ï¼Ÿ
	â€¢	å£°æ˜ â†’ <T extends ...>
	â€¢	ä½¿ç”¨ â†’ ? extends / ? super
2.	è¿™æ˜¯è¯»å¤šè¿˜æ˜¯å†™å¤šï¼Ÿ
	â€¢	è¯» â†’ extends
	â€¢	å†™ â†’ super
3.	è¿è¡ŒæœŸè¦ä¸è¦çŸ¥é“ç±»å‹ï¼Ÿ
	â€¢	è¦ â†’ æ³›å‹å¸®ä¸äº†ä½ 
	â€¢	ä¸è¦ â†’ OK


ğŸŒ°ï¼š
void f(List<? super String> list) {
    String s = list.get(0);
}âŒ
å¯èƒ½æ˜¯Stringæˆ–è€…Object
ä½†æ˜¯ä¸‹é¢å°±ç›´æ¥å˜æˆäº†String
å®‰å…¨èµ·è§åº”è¯¥æ˜¯Object s = list.get(0);


Theoriefragenè®¢æ­£ï¼š
1.Was ist das Hauptziel von Generics in Java und welcher Vorteil ergibt sich gegenÃ¼ber der Verwendung nicht-generischer Typen ?
a.Zur Compilezeit Typsicherheit leisten und unnÃ¶tige Casts vermeiden.âœ…
b.Einen Entwurf erstellen, wenn noch nicht feststeht, fÃ¼r welchen Typ der Code geschrieben werden soll.âŒ
c.Um Funktionen auf mehrere Typen zu Ã¼bertragen und Code-Wiederholungen zu vermeiden.âœ…
d.Die AusfÃ¼hrungszeit beschleunigen.

4.Worin besteht der Unterschied zwischen Wildcards und Generics ?
a.Generics definieren einen Typ fÃ¼r die gesamte (abgeschlossene) Struktur wÃ¤hrend Wildcards nur auf einer konkretten Stelle.âœ…
b.Wildcards waren spÃ¤ter in Java eingefÃ¼hrt und liefern stÃ¤rkere Typsicherheit. Wenn mÃ¶glich, muss man lieber wildcards einsetzen.
c.Wildcards kann man fÃ¼r Arrays benutzen, Generics nicht.
d.Generics schrÃ¤nken eine Struktur (z. B. Klasse, Methode usw.) zur Laufzeit auf einen bestimmten Typ ein. 
Verwendet man statt Generics Ã¼berall Wildcards (?), kann man fÃ¼r jede Variable, 
jeden Parameter und jeden RÃ¼ckgabewert einen beliebigen Typ wÃ¤hlen, was den Code viel flexibler macht.âŒä¸èƒ½éšæ„é€‰ï¼Œæ¯”å¦‚æ•°ç»„å°±ä¸è¡Œ

5.In welchen FÃ¤llen verwendet man "? extends X" bzw. "? super X" ï¼Ÿâ€¼ï¸
a."? super X" wenn man in die Struktur schreibt.âœ…
b."? extends X" nur fÃ¼r die RÃ¼ckgabewerte.
c."? extends X" wenn man aus einer Struktur nur liest.âœ…
d."? super X" nur fÃ¼r die RÃ¼ckgabewerte.





Codefragenè®¢æ­£ï¼š
1.class E<T> {
    public static <T> T up(T x) { return x; }
}âŒ

å¦‚æœæƒ³ç”¨ç±»çš„Té‚£å°±ä¸èƒ½static
class E<T> {
    public T up(T x) { return x; }
}âœ…
â€¼ï¸static æ–¹æ³•ä¸èƒ½ç”¨ç±»çš„ Tï¼šå› ä¸ºç±»çš„ T æ˜¯â€œè·Ÿå¯¹è±¡ç»‘å®šçš„â€ï¼Œstatic æ–¹æ³•æ˜¯â€œä¸è·Ÿä»»ä½•å¯¹è±¡ç»‘å®šçš„â€ã€‚æ‰€ä»¥ static æ–¹æ³•æ ¹æœ¬æ²¡èµ„æ ¼ç”¨ç±»çš„ Tã€‚
æ–¹æ³•å¯ä»¥è‡ªå·±å£°æ˜ <T>ï¼Œä½†åˆ«è·Ÿç±»çš„ T åŒå





â€¼ï¸â€¼ï¸â€¼ï¸2.interface Testable<T extends Number> {
    void apply(T t);
}
ç¡¬çº¦æŸåªæœ‰ä¸¤æ¡ï¼šâ€¼ï¸
	1.	T å¿…é¡»æ˜¯ Number æˆ–å…¶å­ç±»
	2.	å®ç°ç±»é‡Œçš„ apply å‚æ•°ç±»å‹å¿…é¡»å’Œæ¥å£é‡Œçš„ T å¯¹å¾—ä¸Š

a.
class A implements Testable<Integer> {
    public void apply(Integer t) {}
}âœ…
b.
class D implements Testable {
    public void apply(Object t) {}
}âŒboundé”™è¯¯
c.
class B implements Testable<T extends Number>{
    public void apply(T t) {}
}âŒè¦ç»§ç»­ä½¿ç”¨æ³›å‹éœ€è¦å£°æ˜
âœ…æ­£ç¡®çš„æ˜¯
class B<T extends Number> implements Testable<T>{
    public void apply(T t) {}
}

â€¼ï¸ç±»å‹å˜é‡åªèƒ½åœ¨â€œå£°æ˜é˜¶æ®µâ€å£°æ˜ï¼›åœ¨æ¥å£å®ç°ï¼ˆimplementsï¼‰é‡Œåªèƒ½â€œä½¿ç”¨â€¼ï¸â€å·²ç»å£°æ˜è¿‡çš„ç±»å‹ï¼Œä¸èƒ½å†æ¬¡å£°æ˜ã€‚

d.
class E implements Testable<String> { }âŒboundé”™è¯¯
e.
class C<T> implements Testable<T extends Number> {
    public void apply(T t) {}
}âœ…â“â“â“



â€¼ï¸â€¼ï¸â€¼ï¸
1ï¸âƒ£åœ¨æ¥å£é‡Œï¼šå¯ä»¥å£°æ˜ T
interface Testable<T extends Number> {
    void apply(T t);
}
è¿™æ˜¯å£°æ˜é˜¶æ®µ âœ…å…è®¸å†™ T extends Number

2ï¸âƒ£åœ¨å®ç°ç±»é‡Œï¼šæœ‰ä¸¤ç§åˆæ³•é€‰æ‹©ï¼Œç»§ç»­æ˜¯æ³›å‹ï¼ˆç»§ç»­å£°æ˜ Tï¼‰/ å®šæ­»ä¸€ä¸ªå…·ä½“ç±»å‹
ç»§ç»­æ³›å‹ï¼š
class B<T extends Number> implements Testable<T> {
    public void apply(T t) {}
}
å®šæ­»ï¼š
class A implements Testable<Integer> {
    public void apply(Integer t) {}
}

ã€Œå¦‚æœå‰é¢å·²ç»å£°æ˜è¿‡äº†ï¼Œåé¢ä½¿ç”¨çš„æ—¶å€™å°±åªç”¨å‡ºç°ä¸€ä¸ª Tã€
ã€Œå¦‚æœæ˜¯æ–°çš„ä¸€ä¸ªç±»å‹éœ€è¦æ³›å‹ï¼Œé‚£å°±æ˜¯éœ€è¦å£°æ˜å†™å…¨ã€
ã€Œå¦‚æœæ˜¯å®ç°çš„æ—¶å€™ç›´æ¥éœ€è¦å®šæ­»ä¸€ä¸ªå…·ä½“ç±»å‹çš„è¯ï¼Œåœ¨ bound é‡Œé¢é€‰ä¸€ä¸ªå°±å¥½äº†ã€







Recap9 1ğŸˆ·ï¸25æ—¥ 
Thema 9 - Collections

1.Collectionæ˜¯Javaä¸­çš„ä¸€ç§æ¥å£ï¼Œå°†ä¸€ç»„å¯¹è±¡è¡¨ç¤ºä¸ºä¸€ä¸ªæ•´ä½“ã€‚
Collection æ˜¯ List / Set / Queue çš„å…±åŒçˆ¶æ¥å£(Dequeæ˜¯Queueçš„å­ç±»)ï¼›Map æ˜¯å¹¶åˆ—ä½“ç³»ï¼Œä¸å±äº Collectionã€‚

Collectionsæä¾›äº†å¤šç§æ–¹æ³•ï¼Œä»¥é«˜æ•ˆä½œå’Œç®¡ç†å­˜å‚¨æ•°æ®ã€‚â€¼ï¸ä¸€ä¸ªæ˜¯æ¥å£ï¼Œä¸€ä¸ªæ˜¯å·¥å…·ç®±
æœ€åŸºæœ¬é›†åˆæ“ä½œï¼š
add(T a), addAll(Collection) 			// FÃ¼gt Elemente hinzu
- remove(T), clear() 					// Entfernt Elemente
- isEmpty(), contains(T a) 				// PrÃ¼ft auf Elemente / Leerheit
- size() 								// Liefert aktuelle Anzahl der Elemente
- toArray(T[] a) 						// Wandelt Collection in Array um
- stream() 								// Erzeugt einen Stream (siehe Recap 10)



2.Listæ˜¯ Collection çš„ä¸€ä¸ªå­æ¥å£ï¼ˆå­ç±»ï¼šArrayListã€LinkedListâ€¼ï¸è¯´æ˜å®ç°ä¸­å®é™…å¹²æ´»æ˜¯è¿™ä¿©å­ç±»ï¼‰
List extends Collection by enforcing an ordered sequence of elements with index-based access, while allowing duplicates.
å®ƒåœ¨ Collection å®šä¹‰çš„â€œæœ€åŸºæœ¬é›†åˆæ“ä½œâ€ä¹‹ä¸Šï¼Œé¢å¤–å¢åŠ äº†â€œé¡ºåº + ä¸‹æ ‡è®¿é—®(Ordnung + Indexzugriff)â€çš„è¯­ä¹‰ã€‚
ä»€ä¹ˆæ—¶å€™ç”¨åˆ°ï¼Ÿ
å½“ä½ æƒ³ä¿ç•™æ•°ç»„çš„åŠŸèƒ½ï¼ˆç´¢å¼•è®¿é—®ã€é¡ºåºï¼‰ï¼Œä½†åˆæƒ³é¿å…æ•°ç»„çš„é™åˆ¶ï¼ˆå¦‚å›ºå®šå¤§å°æˆ–ç¼ºå°‘æ“ä½œï¼‰æ—¶ï¼Œä¼šç”¨å®ƒã€‚
ä¸ºä»€ä¹ˆ List è¦å•ç‹¬å­˜åœ¨ï¼Œè€Œä¸èƒ½åªç”¨ Collectionï¼Ÿ
Collectionä¸ä¿è¯é¡ºåº ä¸” æ²¡æœ‰index

List<String> l = new ArrayList<>();
Collection<String> c = l; // ä¸ºä»€ä¹ˆè¿™æ˜¯â€œè§£è€¦â€â“
è§£è€¦ = è®©ä»£ç ä¸ä¾èµ–å…·ä½“å®ç°ï¼Œåªä¾èµ–çº¦å®šï¼ˆæ¥å£ï¼‰ã€‚

ArrayList<String> l = new ArrayList<>();
æˆ‘è¿™ä¸ªå˜é‡ï¼Œæ°¸è¿œå‡å®šä½ æ˜¯ ArrayListã€‚â€
ä¸èƒ½ æ¢æˆ LinkedListã€ä¸èƒ½ æ¢æˆ HashSetã€è¢« ArrayList ç»‘æ­»
è¿™æ˜¯å¼ºè€¦åˆâ€¼ï¸

ä½†è§£è€¦ â‰  â€œå®Œå…¨ä¸ä¾èµ–â€
âœ… è§£è€¦ = åªä¾èµ–æŠ½è±¡ï¼ˆæ¥å£ / çº¦å®šï¼‰ï¼Œä¸ä¾èµ–å®ç°ç»†èŠ‚â€¼ï¸
å¼ºè€¦åˆæ˜¯æŒ‡ä»£ç ç›´æ¥ä¾èµ–äºå…·ä½“å®ç°ç±»ï¼›
è§£è€¦æ˜¯æŒ‡ä»£ç ä¾èµ–äºæŠ½è±¡ï¼ˆå¦‚æ¥å£ï¼‰ï¼Œä»è€Œä¸ä¾èµ–å…·ä½“å®ç°ç»†èŠ‚ã€‚

â€¼ï¸ä¸å…è®¸ç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®ç±»å‹
ğŸŒ°ï¼š
List<int> âŒ
List<Integer> âœ…
å› ä¸º Java çš„æ³›å‹åªå¯¹â€œå¼•ç”¨ç±»å‹â€æœ‰æ•ˆï¼Œä¸æ”¯æŒåŸå§‹ç±»å‹ã€‚
â“ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ å› ä¸ºæ³›å‹æ˜¯é  ç±»å‹æ“¦é™¤ æ¥å®ç°çš„ï¼Œ
List<Integer>/List<String>åœ¨ç¼–è¯‘åéƒ½å˜æˆList<Object>ï¼Œè€ŒList<int>ä¸è¡Œ
æ³›å‹åªèƒ½è£…â€œå¯¹è±¡â€ï¼Œint ä¸æ˜¯å¯¹è±¡ï¼ŒInteger æ˜¯ã€‚

int					Integer
åŸå§‹ç±»å‹				å¼•ç”¨ç±»å‹ï¼ˆç±»ï¼‰
ä¸ç»§æ‰¿ Object		ç»§æ‰¿ Object
ç›´æ¥å­˜å€¼				å­˜å¯¹è±¡å¼•ç”¨
æ²¡æ–¹æ³•				æœ‰æ–¹æ³•



3.Setæ˜¯ Collection çš„ä¸€ä¸ªå­æ¥å£ï¼ˆå­ç±»ï¼šHashSetâ€¼ï¸è¯´æ˜å®ç°ä¸­å®é™…å¹²æ´»æ˜¯è¿™ä¿©å­ç±»ï¼‰
Set extends Collection by enforcing uniqueness of elements, while leaving ordering unspecified.
å®ƒåœ¨ Collection çš„åŸºç¡€ä¸Šï¼Œå¢åŠ äº†â€œå…ƒç´ å”¯ä¸€æ€§ï¼ˆæ— é‡å¤ï¼‰â€¼ï¸â€è¿™ä¸€çº¦æŸï¼Œå¹¶ä¸”å…ƒç´ æ²¡æœ‰å›ºå®šé¡ºåºï¼ˆLinkedHashSeté™¤å¤–ï¼‰ã€‚Set æ¥å£æœ¬èº«ä¸ä¿è¯é¡ºåºï¼Œé¡ºåºä¸å¦æ˜¯ å®ç°ç±»çš„ç‰¹æ€§ï¼Œä½†æ˜¯List æ¥å£æœ¬èº«å°±ä¿è¯â€œä¸‹æ ‡è®¿é—® + é¡ºåºâ€
keine Duplikatï¼šæ’å…¥é‡å¤æ€§å…ƒç´ ä¼šè¢«å¿½ç•¥ï¼ˆâ€¼ï¸ä½ å¿…é¡»çŸ¥é“çš„ç²¾ç¡®å®šä¹‰æ˜¯ï¼šSet æ˜¯å¦â€œé‡å¤â€ï¼Œä¸æ˜¯çœ‹ ==ï¼Œè€Œæ˜¯çœ‹â€œç›¸ç­‰æ€§è§„åˆ™â€ã€‚ï¼‰
HashSetï¼šğŸ‘‰ equals() + hashCode()
TreeSetï¼šğŸ‘‰ compareTo() == 0
ğŸ™‹æé—®ï¼šâ€œä¸ºä»€ä¹ˆæˆ‘å¾€ HashSet é‡Œæ”¾äº†ä¸¤ä¸ªçœ‹èµ·æ¥ä¸€æ ·çš„å¯¹è±¡ï¼Ÿâ€
ç­”æ¡ˆå‡ ä¹æ°¸è¿œæ˜¯ï¼šä½ æ²¡æ­£ç¡® override equals / hashCode
If equals and hashCode are not overridden consistently, HashSet cannot detect logically equal objects as duplicates.

ä»€ä¹ˆæ—¶å€™ç”¨åˆ°ï¼Ÿ
- å¦‚æœä½ éœ€è¦ä¸€ç»„å”¯ä¸€å¯¹è±¡ï¼ˆä¾‹å¦‚æ³¨å†Œç¼–å·ï¼‰ã€‚
- åˆ é™¤åˆ—è¡¨ä¸­çš„é‡å¤ç‰©å“ã€‚
- æ•°å­¦ä¸­
- å½“ä½ éœ€è¦å¿«é€Ÿæ£€æŸ¥æŸä¸ªå…ƒç´ æ˜¯å¦å·²ç»å­˜åœ¨æ—¶ã€‚

å…·ä½“æ–¹æ³•ï¼š
add(T elem):æ·»åŠ å…ƒç´ ï¼Œå·²ç»å­˜åœ¨å°±ä¸ä¼šæ·»åŠ ï¼Œå¦‚æœæ·»åŠ æˆåŠŸè¿”å›trueï¼Œåä¹‹è¿”å›false
remove(Object o):åˆ é™¤å…ƒç´ ï¼Œå¦‚æœæ‰¾åˆ°å¹¶åˆ é™¤è¿”å›trueï¼Œåä¹‹è¿”å›false



4.Queue æ˜¯ Collection çš„å­æ¥å£(å­ç±»ï¼šLinkedListéµå¾ªFIFOåŸåˆ™â€¼ï¸è¿™æ˜¯LinkedListåªæœ‰åœ¨Queueä½¿ç”¨æ—¶çš„è¡Œä¸ºã€PriorityQueueæŒ‰ä¼˜å…ˆçº§æ’åˆ—ï¼Œå¹¶éè¿›å…¥é¡ºåº)
Queue extends Collection by enforcing access to elements according to a queue discipline, typically FIFO, without providing positional access.
å®ƒåœ¨æ¥å£å±‚é¢â€¼ï¸åªä¿è¯â€œæŒ‰é˜Ÿåˆ—è¯­ä¹‰å–å…ƒç´ ï¼ˆheadï¼‰â€ï¼Œè€Œä¸ä¿è¯å…·ä½“çš„å­˜å‚¨æˆ–æ’åºæ–¹å¼ã€‚â€¼ï¸è¦ä¸ç„¶åœ¨æ¥å£å±‚é¢ä¿è¯å…·ä½“çš„æ’åºæ–¹å¼çš„è¯PriorityQueueå°±ä¸åˆæ³•
ä½¿ç”¨åœºæ™¯ï¼š
é˜Ÿåˆ—çš„å®ç°ï¼ˆä¾‹å¦‚ä»»åŠ¡è°ƒåº¦å™¨ã€æ¶ˆæ¯é˜Ÿåˆ—ï¼‰
å¤„ç†é¡ºåºè‡³å…³é‡è¦çš„æµç¨‹ã€‚

âš ï¸	headï¼šä¸‹ä¸€æ¬¡è¦è¢«å–å‡ºçš„å…ƒç´ â€¼ï¸ï¼ˆä¸ä¸€å®šæ˜¯ FIFO æ’å…¥æœ€æ—©çš„é‚£ä¸ªï¼›PriorityQueue é‡Œæ˜¯â€œæœ€å°/æœ€é«˜ä¼˜å…ˆçº§â€é‚£ä¸ªï¼‰
ä¸‹é¢æ‰€æœ‰æ–¹æ³•è¯´çš„â€œç¬¬ä¸€ä¸ªå…ƒç´ / Kopfâ€éƒ½æ˜¯æŒ‡ head
å®ç°æ–¹æ³•ï¼š
	1.	çœ‹ä¸çœ‹å¤´å…ƒç´ ï¼ˆpeek/elementï¼‰ vs å–èµ°å¤´å…ƒç´ ï¼ˆpoll/removeï¼‰
	2.	ç©ºé˜Ÿåˆ—æ—¶æ€ä¹ˆå¤„ç†ï¼šè¿”å› null è¿˜æ˜¯æŠ›å¼‚å¸¸
	3.	å…¥é˜Ÿæ˜¯å¦æˆåŠŸï¼šoffer è¿”å› boolean
peek/pollï¼šçœ‹/å– ç©ºé˜Ÿåˆ—->è¿”å›null
element/removeï¼šçœ‹/å– ç©ºé˜Ÿåˆ—->æŠ›å¼‚å¸¸
offerï¼šå…ƒç´ å…¥é˜Ÿï¼Œå¤±è´¥æ—¶è¿”å›false



5.Map ä¸å±äº Collectionï¼Œå› ä¸ºå®ƒçš„åŸºæœ¬æ“ä½œå•ä½ä¸æ˜¯â€œå…ƒç´ â€ï¼Œè€Œæ˜¯â€œé”®â€“å€¼å¯¹â€ã€‚é‡ç‚¹åœ¨äºkeyçš„å”¯ä¸€æ€§â€¼ï¸
Map stores data as keyâ€“value pairs with unique keys and does not belong to the Collection hierarchy.
é”®å€¼å¯¹ï¼šå°†æ•°æ®ä»¥å¯¹çš„å½¢å¼å­˜å‚¨ï¼Œæ¯ä¸ªå€¼å¯¹åº”ä¸€ä¸ªå”¯ä¸€çš„é”®ã€‚â€¼ï¸ä¹Ÿå°±æ˜¯è¯´keyæ˜¯å”¯ä¸€çš„ valueå¯ä»¥å¤šä¸ªå¯¹ä¸€ä¸ªkey
å”¯ä¸€é”®ï¼šå¦‚æœå°è¯•æ·»åŠ å·²æœ‰é”®ï¼Œæ—§å€¼å°†è¢«æ›¿æ¢ä¸ºæ–°é”®ã€‚â€¼ï¸é‡å¤keyä¼šè¢«è¦†ç›–
æ— ä¿è¯é¡ºåºï¼šå¤§å¤šæ•°æ˜ å°„å®ç°ä¸­é”®å’Œå€¼çš„é¡ºåºä¸ä¿è¯ï¼Œæ¯”å¦‚HashMapï¼ˆä¾‹å¤–ï¼šLinkedHashMapæŒ‰ç…§æ’å…¥é¡ºåºã€TreeMapæŒ‰keyé¡ºåºï¼‰ã€‚â€¼ï¸å’ŒSet/Queueçš„è§„åˆ™ä¸€æ ·ï¼šé¡ºåºæ˜¯å®ç°ç±»ç‰¹æ€§ï¼Œä¸æ˜¯æ¥å£æ‰¿è¯º
ä¸å…è®¸ç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®ç±»å‹ã€‚

Collection çš„ä¸–ç•Œè§‚					Map çš„ä¸–ç•Œè§‚
â€¢	æœ€å°å•ä½ï¼šä¸€ä¸ªå…ƒç´  E				â€¢	æœ€å°å•ä½ï¼šä¸€å¯¹ (K, V)
â€¢	åŸºæœ¬æ“ä½œï¼š						â€¢	åŸºæœ¬æ“ä½œï¼š
â€¢	add(E)							â€¢	put(K, V)
â€¢	remove(E)						â€¢	get(K)
â€¢	iterator()						â€¢	remove(K)

ğŸ‘‰ è¯­ä¹‰å®Œå…¨ä¸åŒ


éå†Mapå¯ä»¥é€šè¿‡keySet()å’Œvalues()entrySetï¼Œæˆ–è€…é€šè¿‡valueCollection
1ï¸âƒ£keySet() â€”â€” æ‰€æœ‰ key
Set<K> keys = map.keySet();
for (K k : keys) {
    System.out.println(k);
}
2ï¸âƒ£values() â€”â€” æ‰€æœ‰ value
Collection<V> values = map.values();
for (V v : values) {
    System.out.println(v);
}
3ï¸âƒ£entrySet() â€”â€” key + valueï¼ˆæœ€å¸¸ç”¨ï¼‰
Set<Map.Entry<K,V>> entries = map.entrySet();
for (Map.Entry<K,V> e : entries) {
    System.out.println(e.getKey() + " -> " + e.getValue());
}


è™½ç„¶ Map â‰  Collectionï¼Œä½†ï¼šMap å¯ä»¥â€œæŠ•å½±â€ä¸º Collectionâ“å› ä¸º Map çš„â€œæ•´ä½“â€ä¸æ˜¯ Collectionï¼Œä½†å®ƒçš„â€œç»„æˆéƒ¨åˆ†â€æ˜¯ã€‚
â€¼ï¸æ‹†å¼€çœ‹ Map çš„å†…éƒ¨ç»“æ„ï¼ˆéå¸¸é‡è¦ï¼‰

ä¸€ä¸ª Map é‡Œï¼Œæœ¬è´¨ä¸Šæœ‰ä¸‰æ ·ä¸œè¥¿ï¼š
	1.	ä¸€ç»„ keys â†’ å¤©ç„¶æ˜¯ Set
	2.	ä¸€ç»„ values â†’ å¤©ç„¶æ˜¯ Collection
	3.	ä¸€ç»„ (key, value) å¯¹ â†’ å¤©ç„¶æ˜¯ Set of Entry

æ‰€ä»¥ Java è®¾è®¡è€…è¯´ï¼š
â€œæˆ‘ä¸æŠŠ Map å½“ Collectionï¼Œ
ä½†æˆ‘å…è®¸ä½ æŠŠå®ƒçš„â€˜æŸä¸€ç»´åº¦â€™å½“ Collection æ¥ç”¨ã€‚â€


æ€»ç»“ï¼š
Set/Queue/Mapï¼šé¡ºåºæ˜¯å®ç°ç±»ç‰¹æ€§ï¼Œä¸æ˜¯æ¥å£æ‰¿è¯º
Listï¼šä¸‹è¡¨è®¿é—®+é¡ºåºæ˜¯æ¥å£æ‰¿è¯º

Collection
 â”œâ”€â”€ List   â†’ æœ‰åº + å¯é‡å¤
 â””â”€â”€ Set    â†’ æ— é‡å¤ï¼ˆä¸ä¿è¯é¡ºåºï¼‰
 â””â”€â”€ Queue  â†’ é˜Ÿåˆ—è¯­ä¹‰ï¼ˆhead / tailï¼‰
Map(keyçš„å”¯ä¸€æ€§)   â† å¹¶åˆ—ä½“ç³»




6.PECSï¼šProducer Extends Consumer Super
Producer Extendsï¼šå¦‚æœä½ åªè¯»å–ï¼ˆç”Ÿæˆï¼‰é€šç”¨é›†åˆçš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨<ï¼Ÿextends T>
List<? extends Number>: Sie kÃ¶nnen lesen, aber nichts hinzufÃ¼gen
Consumer Superï¼šå½“ä½ å†™å…¥ï¼ˆæ¶ˆè€—ï¼‰æ•°æ®åˆ°é€šç”¨é›†åˆæ—¶ï¼Œä½¿ç”¨<? super T>
List<? super Integer>: Sie kÃ¶nnen hinzufÃ¼gen, aber beim Lesen bekommen Sie Object.



7.å¸¸è§è¯¯åŒºFehlvorstellungï¼šå…¨âŒ
- Map gehÃ¶rt zu Collection.
- Jedes Collection hat eine bestimmte Reihenfolge von Elementen.
- List<Object> ist ein Supertyp von List<String>.
- Collections kÃ¶nnen primitive Datentypen speichern.
- Falls man ein Duplikat in Set einfÃ¼gt, dann wird ein Exception geworfen.///ä¼šè¢«å¿½è§†
- Map.get(key) wirft immer eine Exception, wenn der SchlÃ¼ssel nicht existiert./////Map.get(key) åœ¨ key ä¸å­˜åœ¨æ—¶è¿”å› nullï¼Œè€Œä¸æ˜¯æŠ›å¼‚å¸¸ã€‚


8.å¸¸è§é”™è¯¯âŒ
Ignorieren von null-Werten in Map.get()ï¼š
map.get(key)ï¼š
	â€¢	key ä¸å­˜åœ¨ â†’ è¿”å› null
	â€¢	æˆ–è€… key å­˜åœ¨ï¼Œä½† value æœ¬æ¥å°±æ˜¯ nullï¼ˆæŸäº› Map å…è®¸)

æ‰€ä»¥å¦‚æœç›´æ¥ï¼šmap.get(k).toString() å°±å¯èƒ½ NullPointerExceptionã€‚
è§£å†³æ–¹æ³•ï¼š
1ï¸âƒ£å…ˆåˆ¤æ–­if (map.containsKey(k)) { ... }
2ï¸âƒ£ç»™é»˜è®¤å€¼  V v = map.getOrDefault(k, defaultV);


åœ¨éå†é›†åˆçš„åŒæ—¶ï¼Œç”¨é›†åˆæœ¬èº«çš„æ–¹æ³•ä¿®æ”¹ç»“æ„ï¼ˆadd / removeï¼‰ï¼Œå°±ä¼šè§¦å‘ ConcurrentModificationException
for (String s : list) {////for eachæœ¬è´¨ä¸Šå°±æ˜¯iterator
    if (s.equals("A")) {
        list.remove(s);   // ğŸ’¥
    }
}
æ­£ç¡®âœ…ï¼šä½¿ç”¨iterator
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String s = it.next();
    if (s.equals("A")) {
        it.remove();   // âœ…
    }
}
åŒºåˆ«åœ¨äºï¼šç”¨iteratorä¿®æ”¹æ˜¯åˆæ³•ï¼Œç»•è¿‡iteratorä¿®æ”¹ä¸åˆæ³•
Iterator åªå…è®¸ä½ ç”¨â€œå®ƒè‡ªå·±â€çš„ remove() æ¥ä¿®æ”¹é›†åˆã€‚
ä»»ä½•ç›´æ¥è°ƒç”¨ list.remove() éƒ½æ˜¯åœ¨ç»•å¼€å®ƒã€‚





Theoriefragenè®¢æ­£ï¼š
1.Welche Aussagen Ã¼ber Collections sind korrekt?
a.Sie unterstÃ¼tzen generische Datentypen.âœ…
b.Sie ermÃ¶glichen das Speichern mehrerer Objekte.âœ…
c.Alle Collections funktionieren mehr oder weniger gleich, da sie ein gemeinsames Interface implementieren.âœ…
æ‰€æœ‰ Collections æˆ–å¤šæˆ–å°‘å·¥ä½œæ–¹å¼ç›¸åŒï¼Œå› ä¸ºå®ƒä»¬å®ç°äº†ä¸€ä¸ªå…±åŒçš„æ¥å£ã€‚
d.Da sie generisch sind, kÃ¶nnen sie nicht nur komplexe, sondern auch primitive Datentypen speichern.

2.Welche Eigenschaften gelten fÃ¼r alle Collection-Typen in Java?
a.Sie kÃ¶nnen Objekte speichernâœ…
b.Sie erlauben den Zugriff Ã¼ber einen numerischen Index
c.Sie unterstÃ¼tzen das HinzufÃ¼gen und Entfernen von Elementenâœ…
d.Sie garantieren die Reihenfolge der Elemente
e.Sie implementieren das Interface java.util.Collectionâœ…///è¿™å¥è¯çš„æ„æ€æ˜¯ æ‰€æœ‰Collectionç±»å‹çš„éƒ½æ˜¯å®ç°äº†Collectionæ¥å£
f.Sie unterstÃ¼tzen primitive Datentypen direkt



3.Welche Interfaces gehÃ¶ren zur Java Collection API?
a.Setâœ…
b.Map
c.Listâœ…
d.Stream
e.Iteratorâœ…
f.Queueâœ…

å…³é”®åœ¨é¢˜ç›®çš„â€œAPIâ€ä¸¤ä¸ªå­—
Java Collection API â‰  java.util.Collection æ¥å£ä½“ç³»
Java Collection APIï¼ˆæˆ– Collections Frameworkï¼‰ åŒ…å«ï¼š
	â€¢	Collection æœ¬èº«
	â€¢	æ‰€æœ‰å…¶å­æ¥å£
	â€¢	ä»¥åŠç”¨æ¥æ“ä½œ Collection çš„é…å¥—æ¥å£
ğŸ‘‰ Iterator æ­£æ˜¯è¿™ç§â€œé…å¥—æ¥å£â€



4.Welche Aussagen Ã¼ber Set sind korrekt?
a.Im Gegensatz zu Map, ist das Speichern von doppelten Objekten oder Werten im Set nicht erlaubtâœ…åœ¨seté‡Œé¢å­˜å‚¨ä¸¤ä¸ªé‡å¤çš„å¯¹è±¡æˆ–è€…å€¼æ˜¯ä¸å…è®¸çš„ï¼ŒMapå½“ä¸­å¯ä»¥å…è®¸å€¼å­˜ä¸¤ä¸ªä¸€æ ·çš„ï¼Œsetæ˜¯ä¿è¯æ— é‡å¤æ‰€ä»¥å¯¹
b.In einem Set kÃ¶nnen keine doppelten Objekte/Werte gespeichert werdenâœ…
c.Ein Set hat eine feste LÃ¤nge
d.Set kann nur einen Wert speichern, der Ã¼ber die Methode set() hinzugefÃ¼gt wurde
e.Dieses Interface wird verwendet, um Werte in andere Collections zu speichern


5.Welche Aussagen Ã¼ber die Unterschiede zwischen List und Array sind korrekt?
a.Man kann auf Elemente eines Arrays durch den Index zugreifen, in einer Liste jedoch nicht
b.Ein Array hat eine feste LÃ¤nge, wÃ¤hrend eine Liste keine feste LÃ¤nge hatâœ…
c.Elemente eines Arrays haben eine Reihenfolge, aber die Elemente einer List nicht
d.Man kann ein Array von Arrays erstellen, aber keine Liste von ListenâŒ
List<List<Integer>> list = new ArrayList<>();âœ… 
ğŸ‘‰ Java æ³›å‹æ˜¯å¯åµŒå¥—çš„
ğŸ‘‰ List æœ¬æ¥å°±æ˜¯å¯¹è±¡çš„é›†åˆ
ğŸ‘‰ List<List> æ²¡æœ‰ä»»ä½•è¯­æ³•æˆ–è¯­ä¹‰é™åˆ¶
e.Die LÃ¤nge eines Arrays kann Ã¼ber length abgerufen werden, die LÃ¤nge einer Liste jedoch Ã¼ber size()âœ…




7.Welche Vorteile bieten Collections gegenÃ¼ber Arrays?
a.Sie sind schneller als Arrays
b.Sie speichern automatisch nur eindeutige Werte
c.Sie haben eine flexible GrÃ¶ÃŸeâœ…
d.Sie unterstÃ¼tzen Such- und Sortierfunktionenâœ…
Arrayç±»å‹æ²¡æœ‰SortåŠŸèƒ½


9.Was ist der Unterschied zwischen ArrayList und LinkedList?
a.ArrayList kann keine null-Werte speichern
b.LinkedList ist effizienter beim EinfÃ¼gen und Entfernen von Elementenâœ…
c.Beide speichern Daten identisch im Speicher, und der Unterschied in den Methoden liegt
d.ArrayList hat schnelleren Zugriff Ã¼ber Indexâœ…å› ä¸º ArrayList æ˜¯åŸºäºè¿ç»­æ•°ç»„å®ç°çš„ï¼Œæ”¯æŒ O(1) çš„éšæœºè®¿é—®ï¼›LinkedList æ˜¯é“¾è¡¨ï¼ŒæŒ‰ç´¢å¼•è®¿é—®æ˜¯ O(n)ã€‚


10.Welche Collection-Typen garantieren eine bestimmte Reihenfolge?
a.TreeSetâœ…TreeSet ä¹Ÿä¿è¯é¡ºåºï¼Œä½†å®ƒä¿è¯çš„æ˜¯â€œæ’åºé¡ºåºï¼ˆSortierreihenfolgeï¼‰â€ã€‚
b.HashMap
c.LinkedListâœ…ä¿è¯æ’å…¥é¡ºåº
d.HashSet


12.
Welche Aussagen Ã¼ber Queue sind korrekt?
a.Queue erlaubt keine Duplikate
b.Queue ist generisch, aber auch fÃ¼r primitive Datentypen geeignetâœ…
c.Elemente werden am Ende entfernt und am Anfang eingefÃ¼gtâœ…
d.Das erste eingefÃ¼gte Element wird als Erstes entferntâœ…
e.Das erste eingefÃ¼gte Element wird als Letztes entfernt





Codefragenè®¢æ­£ï¼š
















