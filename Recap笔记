Recap 1 10🈷️20日


/ 除法运算 计算商      7 / 3 = 2（整数除法）或 2.333...（浮点除法）
% 取余运算 计算余数    7 % 3 = 1

code订正
1️⃣korrekte Deklaration & Initialisierung
boolean l1keTearsInTheRain;✅(只作为声明的话)

2️⃣korrekte Initialisierung
boolean d;❌因为布尔值是局部变量（在方法、if 块、for 块、while 块等里面定义的变量）。所有局部变量在使用前都必须显式赋值
char e = "e";❌ 对于char是'' ->char e = 'e';

float b = 5;✅（int->float是允许的，会自动类型提升）
float c = 5.0f;✅
Integer g = new Integer(5);✅

3️⃣
Integer a = new Integer(4);
Integer b = a;
a = new Integer(5);
// Welchen Wert hat b?
选项：
Objekt von Typ Integer mit dem Wert 5
Es gibt einen Fehler
null
5
Objekt von Typ Integer mit dem Wert 4✅
4

4️⃣
int a = (5 + 2) / 2;        a=3
float b = (3 + 4) / 3;      b=7/3
int c = (int) ((a + b) % 42);  ///强制类型转换（type cast）只保留int部分


5️⃣print和println的区别：有没有换行

System.out.print("Hello");
System.out.print("World"); ————>HelloWorld

System.out.println("Hello");
System.out.println("World");————>Hello
                                 World

6️⃣
Wie kann man den Wert der Variablen a in die Konsole ausgeben, wenn sie ein Objekt ist?
System.out.print(a.value);
System.out.println(a);
System.out.print(a.val);
Keine der oben genannten Optionen✅
System.out.print(a);
解答：
在 Java 中，对象变量保存的不是“值”，而是“引用”（即内存地址）。
此时，Java 会调用 a.toString() 方法。而默认的 toString() 输出是：类名@哈希码
所以为了输出真正的值：1.类自己覆盖（override）了 toString() 方法； 2.通过 Getter 方法访问字段❓
1.类自己覆盖（override）了 toString() 方法 意思就是在当前这个类当中，我们重写toString这个方法到我们需要的值，或者像这里例子里的名字，然后再直接打印需要的变量，就是我们需要的值


7️⃣Welche Variablen sind an der markierten Stelle im folgenden Code sichtbar?
public void testMethod(int a) {
    int b = 0;
    if (b > 0) {
        int c = 2;
    }
    // Welche Variablen sind hier sichtbar? Loesung:a,b
    int d = 1;
}
	•  a（方法参数）：整个方法体内可见 → 在标记处可见。
	•  b（在方法体内声明）：从声明处开始到方法结束 → 在标记处可见。


8️⃣第15题‼️
实际上考查的是 在println的作用域内有哪些变量
这里引申了一个{}的知识点，有时候无中生有的花括号其实是圈地自圆，就是为了隔开这种作用域在整个方法体内的方法，也就是说题目里的l它只活在花括号内

9️⃣第17题‼️
a,b,c它们定义在类体内、方法外。所以它们的作用域是：是属于整个类的所有方法中都可访问（同一个对象实例内）。

重点关注：嵌套块的作用域



Recap2 10🈷️27日

1.do-while语句 do{schleifenrumpf} while(条件); 因此循坏至少执行一次，因为检查条件在后面
2.循环语句的转化
(1)for语句及其他语句的转化
for(int i = 0; i < 5; i++){
// deinen Code hier
}

int i = 0;
while(i < 5){
// deinen Code hier
i++;
}

int i = 0;
do {
if(i > -1){
// deinen Code hier
}
i++;
}
while(i < 5);

(2)while语句及其他语句的转化
while(bedingung){
// deinen Code

for (; bedingung;){
// deinen Code
}

do{
 if(bedingung){
 // deinen Code
 }
}
while(bedingung);


3.break和continue的区别
关键字		作用对象			执行效果
break		整个循环			立即终止整个循环（跳出循环体）
continue	当前循环的一次迭代	立即跳到下一次循环（跳过当前迭代中剩余的语句）


4.for循环语句的结构
for(Initialisierung;Bedingung;Inkrement)


theorie订正
1️⃣使用for循环语句的条件：知道次数
使用while循环语句的条件：不知道次数

2️⃣for循环语句Kopf构造(Initialisierung;Bedingung;Aktualisierung‼️)

3️⃣continue不能在Schleifenrumpf以外使用，是语义错误

4️⃣break的作用：Beendet die gesamte Schleife vollständig
⚠️不是Überspringt den Rest des Schleifenrumpfs(只是跳过当前Iteration的剩余部分)
continue的作用：Überspringt den Rest des Schleifenrumpfs und geht zur nächsten Iteration

5️⃣continue和break只要在循环rumpf里面就可以，不限定循环语句类型

6️⃣for循环语句的头部三部分哪一部分是可以舍弃的？A：全部
for( ; ; ){
    // Endlosschleife !!!
}
7️⃣在一个循环的头部条件一直是true，那就会一直执行，直到手动break或者报错

8️⃣计算嵌套循环的次数：根据内层循环在每次外层迭代的时候，循环的次数是否都相同来判断，如果相同那就可以内外两层的循环次数相乘等于总循环次数，如果不同的话，那计算总循环次数就要使用加法

9️⃣❌Die innere Schleife wird parallel zur äußeren ausgeführt, was die Parallelisierung des Codes erleichtert
循环的本质是顺序执行，并不是并行执行



code订正
1️⃣
int i = 0;
while(i < 5){
    int sum = i;
    i++;
}
✅Sie durchläuft die Zahlen von 0 bis 5 und speichert den aktuellen Wert in der Variablen i

2️⃣int j = 1;
do {
    int i = 1;
    i = 5 + j;
    j *= 2;
}
while(i < 2);
✅Keine, da ein Kompilierungsfehler enthalten ist‼️🤔
因为i在花括号当中，出了花括号i就不存在，所以无法在while当中检查i的条件

3️⃣代码Äquivalenz判断标准：
如果两段循环产生的输出全相同，那么它们被视为等价（äquivalent）。

4️⃣System.out.println()：
打印一个换行符（newline），不打印任何其它字符。
==>表示换到下一行

5️⃣0 % 2 == ？
答案等于0
因为余数永远小于除数（2）。







Recap3 11🈷️3日

1.Arrays固定的speicherplatz，大小不能改变
int a[] = {1,2,3,4,5}
对于简单数据结构：只能是和自己array同类型的数据
复杂类型array：同类型&子类的类型（比如number的子类是integer和float）

2.为什么使用arrays？
在同一个名字下存储多个数据；通过index获取；适用于循环和批量处理

3.Array的声明
Typ[] nameDerVariable = new Typ[ LängeAlsGanzzahl ];

4.在array只声明，不初始化时：
Integer[] a;此时这个array不存在，会编译错误‼️在 Java 中，new int[] 这个写法必须要么指定长度，要么立刻给出初始化列表，否则编译器会不知道要分配多大的空间。
如果你要给其中一个位置初始化a[0] = 4; -> 会报错
此时也不能调用和这个array属性相关的a.length 会抛出NullPointerException

5.只用标准值初始化时（只创建了array且写了长度）：
int[] a = new int [5]; 此时每个位置都是0（boolean-false; float-0.0f）‼️
‼️无法调用a[i].method()/a.attribute  ->  会抛出NullPointerException
✅但是是合法的，只是无法调用空数组的参数和方法

6.填充array的元素：
int[] zahlen = new int[5];
for (int i = 0; i < zahlen.length; i=+) {
	System.out.println(zahlen[i]);
}
Alternativ：
for (int zahl : zahlen) {
	System.out.println(zahl);
}
‼️for (Type elementName : arrayName){
	System.out.println(elementName);//自己取的elementName
}


7.多维arrays（二位数组中的结构形式）
rechteckig矩形状：int[][] a = new int[2][9] (矩形2x9)
jagged锯齿状：
int[][] b= new int[2][];///只确认外层元素
b[0] = new int[4];///第一行4个元素：内层元素确认
b[1] = new int[2];///第二行2个元素


8.arrays常见的报错：
ArrayIndexOutOfBoundsException：index在有效边界外（一般发生在：循环边界错误）
NullPointerException：调用了未初始化的array或者元素（只声明了，但是未初始化，即使声明了长度）
错将length写成length();
不相容的元素类型:声明的数组类型与元素类型不符；
arrays的打印方法：
1️⃣
int[][] matrix = {{1, 2}, {3, 4}};
for (int i = 0; i < matrix.length; i++) {
	for (int j = 0; j < matrix[i][j].length; j++) {
    	System.out.print(matrix[i] + " ");
	}
    System.out.println();/////这是换行
}
输出：
1 2 
3 4 
2️⃣Arrays.toString(a);这是系统自动打印！！！！只输出一行且无法控制输出格式
比如一维数组：‼️int[] a = {1, 2, 3};System.out.println(Arrays.toString(a));
多位数组：int[][] b = { {1, 2}, {3, 4} };
System.out.println(Arrays.deepToString(b));‼️deepTo T也要大写




9.一维和二维的数组示例
// Eindimensionales Array (Kurzschreibweise)
int[] numbers = {1, 2, 3};
int[] zahlen = new int[3];
zahlen[0] = 1;
zahlen[1] = 2;
zahlen[2] = 3;
// Zweidimensionales Array (Kurzschreibweise)
int[][] matrix = {
{1, 2, 3},
{4, 5, 6},
{7, 8, 9}
};


10.小作业✍️
1️⃣Array-Inhalt ausgeben (for-each) 
2️⃣Summe aller Elemente berechnen
3️⃣二维数组迭代




theorie订正
1️⃣Arrays in Java：Es ist eine Datenstruktur, in der Elemente desselben Typs gespeichert werden.
Java 规定：
数组的所有元素都必须是相同的编译时类型（compile-time type）。
这句话的关键是——“编译时看来是同一类型”，
但“运行时实际存的对象”可以是这个类型的子类实例。

2️⃣在 Java 里可以创建一个长度为 0 的数组✅
Java 中数组的创建语法：Typ[] name = new Typ[ganze positive Zahl];
因为 0 也是一个整数，所以编译器不会报错，运行也正常。
⚠️只是长度为0的数组不能调用这个数组的参数和方法


3️⃣两个数组的相等性能通过==来比较❌‼️引用类型和基本类型的区别
1.数组是引用类型，用 == 比较引用类型时，比较的不是内容，而是地址（Referenz/Identität）
‼️因为 == 比较的是：“两个变量是否指向同一个对象（同一个 Speicheradresse）”。
如果想要比较两个数组的内容是否相等，System.out.println(Arrays.equals(a, b)); // 比较a、b两个数组
（多位数组）System.out.println(Arrays.deepEquals(a, b));


引用类型（Reference Type） 是一种变量，它不直接存储数据本身，而是存储数据在内存中的地址（引用）。

类型类别							举例															存的是什么				存在哪里
基本类型 (Primitive Types)		int, double, boolean, char, …								直接存储值本身				栈 (Stack)
引用类型 (Reference Types)		String, 数组 (int[], String[]), 对象 (Person, Scanner)		存的是对象在堆里的地址		栈上存引用，堆上存对象

比如说：
基本类型int a = 5；  -> a 里真的就是数字 5
引用类型像是一个“信箱号”，里面装的是地址：String s = "Hello";
s 变量里存的不是 “Hello”，而是“Hello” 在内存中那块区域的地址（引用）。



4️⃣数组的优点：Einfache und schnelle Zugriffsmöglichkeiten über Indizes✅

Sie speichern Daten dauerhaft auf der Festplatte❌数组是内存（RAM）里的临时数据结构。程序结束后数组消失，除非你显式地把内容写进文件（那是 IO 操作，不是数组的功能）。


5️⃣Was passiert, wenn man versucht, auf ein Element außerhalb des gültigen Indexbereichs zuzugreifen?
Es wird eine Exception zur Laufzeit ausgelöst（程序运行时会抛出一个异常）✅

Das Programm wird kompiliert, aber mit Warnung❌
“编译通过” 就是说 —— 这段代码在语法上合法，编译器能把它翻译成可执行的字节码。
它不会报“Syntax Error”，但不代表程序运行时不会出错。



Codefragen
1️⃣数组声明：必须要么指定长度，要么立刻给出初始化列表。 ｜
否则编译器会不知道要分配多大的空间，compiler错误	    ｜
‼️但是数组可以只声明int[] a;合法✅				｜
但是不能半吊子声明int[] a = new int [];此时<—————｜

2️⃣数组长度为0可以访问length，只有当没有给定长度时-> NullPointerException

3️⃣一个数组只给定了长度，没有初始化，那么此时打印某一个元素可以吗？看类型分情况‼️
1.基本类型数组int，boolean，float....可以
2.引用类型数组String.....可以打印元素但是运行时抛 NullPointerException⚠️


4️⃣Ausgabe？
int[] arr = new int[5];
arr[4] = 5;
System.out.println(arr[42 % arr.length]);
答案：0


5️⃣Ausgabe？🤔
int[] arr = new int[0];
for (int num : arr) {
    System.out.println(num);
}
答案：什么都没有
‼️这里代码本质上等于
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    System.out.println(num);
}
所以循环条件 i < arr.length 一开始就为 false。
循环体根本不会被执行一次。
控制台什么都不会输出。


6️⃣Ausgabe？
int[] arr = {1, 2, 3};
for (int num : arr) {
    num = num * 2;
}
System.out.println(arr[0]);


for (int num : arr)这句话等价于：
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    num = num * 2;
}
答案是：1
关键点 ⚠️：num 只是 arr[i] 的一个副本（copy）。修改 num 不会反过来改变 arr[i]。
---> 数组 arr 完全没有被修改。



7️⃣Ausgabe？
int[] arr = null;❓我想问这里给数组赋值null是等同于建立了一个长度为0的数组吗？A：一个是“什么都没有”，另一个是“有东西，但里面空”。arr 指向一个长度为 0 的数组对象
for (int num : arr) {
    System.out.println(num);
}
答案是： NullPointerException



‼️‼️‼️首先要理解：增强型 for 的本质
增强 for 循环其实是编译器帮你自动生成的代码，
等价于：
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    System.out.println(num);
}

在执行 for-each 前，Java 会先去调用：
arr.iterator()   // 对集合
arr.length       // 对数组
但是arr 是 null，所以一旦访问 .length就会抛出：NullPointerException











Recap 11🈷️10日
1.类的作用：Information和Methode的Container
类定义：
	属性：描述对象的状态
	方法：描述对象可以做什么

2.Konstruktor构造器
你可以在同一个类中定义多个构造函数，只要它们的参数列表不同即可。
也就是构造函数可以被重载（überladen）。
例如：
class Auto {
    Auto() {}                  // 无参构造
    Auto(String marke) {}      // 一个 String 参数
    Auto(String marke, int bj) {} // 两个参数
}


3.构造方法的时候使用this把参数赋值给属性
也就是说 如果我们在构造一个方法的时候 传进来的参数名和我们需要构造的属性名字一样，那么把参数赋值给这个属性的时候使用this，不同就不用使用this
例如：
public Student(String n, int matrikelnummer) {
    name = n;                        // ❶
    this.matrikelnummer = matrikelnummer;  // ❷
}


4.this的作用：对当前对象的引用
1️⃣在对象方法和构造函数中使用
2️⃣指向当前运行该方法的对象。
3️⃣用于区分同名的属性和参数。
4️⃣‼️在静态方法中不允许，因为没有对对象的引用！


5.static的作用：
1️⃣静态元素（属性/方法）属于类，而不是单个对象。
2️⃣所有对象共享相同的静态属性值（参见第 5、9 页）。
3️⃣通过类名而不是通过对象调用。


6.final的作用
1️⃣最终变量 - Wert bleibt konstant
2️⃣final method - 不能override重写
3️⃣final class - 类不能继承（扩展）


7.其他的访问修饰符
‼️图



8.继承：一个类可以扩展（继承）另一个类。
1️⃣父类的所有方法和属性都是继承的（除非它们是私有的）。
2️⃣您可以在子类中创建新的方法、属性和构造函数
3️⃣您可以覆盖现有方法（意思是：当一个类继承了另一个类后，子类可以重新定义父类里已有的方法，）
4️⃣一个类只能继承一个类！



9.override重写和overload重载区别
1️⃣重写出现在继承关系（父类和子类之间）中：
	•	方法签名完全相同（名字、参数、返回类型、修饰符都相同）
	•	但方法内部实现不同

2️⃣重载出现在同一类中：
	•	同一个类里（derselben Klasse）
	•	方法名相同，但：
	•	参数个数不同，或
	•	参数类型不同，或
	•	访问修饰符不同
	•	功能：让同名方法有多种“输入形式”


✅一句话总结：
重载（Überladen） = 同类中，同名不同参数；
重写（Überschreiben） = 子类中，完全同名同参‼️但重写实现。


10.静态类型和动态类型
静态类型：
1️⃣在编译时设置。
2️⃣决定允许访问哪些方法和属性（对于对象）。
3️⃣换句话说，它限制了动态类型对外界可见的内容。
动态类型：
1️⃣在运行时确定。
2️⃣决定实际执行方法的哪个实现。
3️⃣包含具体对象的属性和构造函数逻辑的具体值。


11.多态
在运行时（Laufzeit），程序根据**对象的真实类型（dynamischer Typ）**来决定调用哪个方法，而不是根据引用的声明类型（statischer Typ）。见下⬇️
例如：
class Animal {
    void makeSound() {
        System.out.println("sound");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("wow");
    }
}

Animal a1 = new Animal();
Animal a2 = new Dog();

a1.makeSound(); // 输出 sound
a2.makeSound(); // 输出 wow

‼️比如这里a2声明是Animal但是实际运行的时候引用的是一个 Dog 对象，所以输出wow




12.继承和构造器
子类不会继承父类的构造函数，但每次创建子类对象时，父类构造函数一定会先被执行。
若父类没有默认构造函数，就必须在子类构造函数第一行显式写 super(...)。
class Parent {
    Parent(int x) {} // 只有有参构造函数
}

class Child extends Parent {
    Child() {
        super(10); // ✅ 必须显式调用，因为父类没有默认构造
    }
}
🔸 而且：
super(...) 必须是子类构造函数的第一行语句！
否则编译会报错。

默认构造函数：没有参数的构造函数。
如果你没有写任何构造函数，Java 编译器会自动为你生成一个这样的无参构造函数。
例如：
我们写没有参数的构造函数
class Cat {
    String name;
}
Java 会自动生成一个：
Cat() { }      这就是默认构造函数

‼️也就是说：如果父类自己构造了一个有参函数，那么子类必须在第一行写super;父类如果是无参函数，也就是父类有默认构造函数，那么super就可以不用写，编译器会自动提供
🧐为什么要这么做？
因为一个子类对象，其实是“包含了父类部分 + 子类部分”的一个整体结构。
你要建二楼（子类对象）时，必须先让一楼（父类）结构稳定（super()），否则二楼建上去就坍塌。
让父类结构稳定，也就是让父类的属性先初始化，所以在父类自己没有默认构造函数的时候，需要我们自己写super来初始化父类属性


13.Objekt：是所有类的父类

每个类都会自动继承自 Object，即使您不编写扩展。
这意味着 - 每个类都继承了 Object 的基本方法，例如：

toString() → 返回对象的字符串表示
equals(Object o) → 比较对象内容是否相等
hashCode() → 返回对象的哈希值（数值表示）
getClass() → 返回对象的运行时类型（类信息）


……各个Module的Code实现











