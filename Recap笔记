Recap 1 10🈷️20日


/ 除法运算 计算商      7 / 3 = 2（整数除法）或 2.333...（浮点除法）
% 取余运算 计算余数    7 % 3 = 1

code订正
1️⃣korrekte Deklaration & Initialisierung
boolean l1keTearsInTheRain;✅(只作为声明的话)

2️⃣korrekte Initialisierung
boolean d;❌因为布尔值是局部变量（在方法、if 块、for 块、while 块等里面定义的变量）。所有局部变量在使用前都必须显式赋值
char e = "e";❌ 对于char是'' ->char e = 'e';

float b = 5;✅（int->float是允许的，会自动类型提升）
float c = 5.0f;✅
Integer g = new Integer(5);✅

3️⃣
Integer a = new Integer(4);
Integer b = a;
a = new Integer(5);
// Welchen Wert hat b?
选项：
Objekt von Typ Integer mit dem Wert 5
Es gibt einen Fehler
null
5
Objekt von Typ Integer mit dem Wert 4✅
4

4️⃣
int a = (5 + 2) / 2;        a=3
float b = (3 + 4) / 3;      b=7/3
int c = (int) ((a + b) % 42);  ///强制类型转换（type cast）只保留int部分


5️⃣print和println的区别：有没有换行

System.out.print("Hello");
System.out.print("World"); ————>HelloWorld

System.out.println("Hello");
System.out.println("World");————>Hello
                                 World

6️⃣
Wie kann man den Wert der Variablen a in die Konsole ausgeben, wenn sie ein Objekt ist?
System.out.print(a.value);
System.out.println(a);
System.out.print(a.val);
Keine der oben genannten Optionen✅
System.out.print(a);
解答：
在 Java 中，对象变量保存的不是“值”，而是“引用”（即内存地址）。
此时，Java 会调用 a.toString() 方法。而默认的 toString() 输出是：类名@哈希码
所以为了输出真正的值：1.类自己覆盖（override）了 toString() 方法； 2.通过 Getter 方法访问字段❓
1.类自己覆盖（override）了 toString() 方法 意思就是在当前这个类当中，我们重写toString这个方法到我们需要的值，或者像这里例子里的名字，然后再直接打印需要的变量，就是我们需要的值


7️⃣Welche Variablen sind an der markierten Stelle im folgenden Code sichtbar?
public void testMethod(int a) {
    int b = 0;
    if (b > 0) {
        int c = 2;
    }
    // Welche Variablen sind hier sichtbar? Loesung:a,b
    int d = 1;
}
	•  a（方法参数）：整个方法体内可见 → 在标记处可见。
	•  b（在方法体内声明）：从声明处开始到方法结束 → 在标记处可见。


8️⃣第15题‼️
实际上考查的是 在println的作用域内有哪些变量
这里引申了一个{}的知识点，有时候无中生有的花括号其实是圈地自圆，就是为了隔开这种作用域在整个方法体内的方法，也就是说题目里的l它只活在花括号内

9️⃣第17题‼️
a,b,c它们定义在类体内、方法外。所以它们的作用域是：是属于整个类的所有方法中都可访问（同一个对象实例内）。

重点关注：嵌套块的作用域



Recap2 10🈷️27日

1.do-while语句 do{schleifenrumpf} while(条件); 因此循坏至少执行一次，因为检查条件在后面
2.循环语句的转化
(1)for语句及其他语句的转化
for(int i = 0; i < 5; i++){
// deinen Code hier
}

int i = 0;
while(i < 5){
// deinen Code hier
i++;
}

int i = 0;
do {
if(i > -1){
// deinen Code hier
}
i++;
}
while(i < 5);

(2)while语句及其他语句的转化
while(bedingung){
// deinen Code

for (; bedingung;){
// deinen Code
}

do{
 if(bedingung){
 // deinen Code
 }
}
while(bedingung);


3.break和continue的区别
关键字		作用对象			执行效果
break		整个循环			立即终止整个循环（跳出循环体）
continue	当前循环的一次迭代	立即跳到下一次循环（跳过当前迭代中剩余的语句）


4.for循环语句的结构
for(Initialisierung;Bedingung;Inkrement)


theorie订正
1️⃣使用for循环语句的条件：知道次数
使用while循环语句的条件：不知道次数

2️⃣for循环语句Kopf构造(Initialisierung;Bedingung;Aktualisierung‼️)

3️⃣continue不能在Schleifenrumpf以外使用，是语义错误

4️⃣break的作用：Beendet die gesamte Schleife vollständig
⚠️不是Überspringt den Rest des Schleifenrumpfs(只是跳过当前Iteration的剩余部分)
continue的作用：Überspringt den Rest des Schleifenrumpfs und geht zur nächsten Iteration

5️⃣continue和break只要在循环rumpf里面就可以，不限定循环语句类型

6️⃣for循环语句的头部三部分哪一部分是可以舍弃的？A：全部
for( ; ; ){
    // Endlosschleife !!!
}
7️⃣在一个循环的头部条件一直是true，那就会一直执行，直到手动break或者报错

8️⃣计算嵌套循环的次数：根据内层循环在每次外层迭代的时候，循环的次数是否都相同来判断，如果相同那就可以内外两层的循环次数相乘等于总循环次数，如果不同的话，那计算总循环次数就要使用加法

9️⃣❌Die innere Schleife wird parallel zur äußeren ausgeführt, was die Parallelisierung des Codes erleichtert
循环的本质是顺序执行，并不是并行执行



code订正
1️⃣
int i = 0;
while(i < 5){
    int sum = i;
    i++;
}
✅Sie durchläuft die Zahlen von 0 bis 5 und speichert den aktuellen Wert in der Variablen i

2️⃣int j = 1;
do {
    int i = 1;
    i = 5 + j;
    j *= 2;
}
while(i < 2);
✅Keine, da ein Kompilierungsfehler enthalten ist‼️🤔
因为i在花括号当中，出了花括号i就不存在，所以无法在while当中检查i的条件

3️⃣代码Äquivalenz判断标准：
如果两段循环产生的输出全相同，那么它们被视为等价（äquivalent）。

4️⃣System.out.println()：
打印一个换行符（newline），不打印任何其它字符。
==>表示换到下一行

5️⃣0 % 2 == ？
答案等于0
因为余数永远小于除数（2）。







Recap3 11🈷️3日

1.Arrays固定的speicherplatz，大小不能改变
int a[] = {1,2,3,4,5}
对于简单数据结构：只能是和自己array同类型的数据
复杂类型array：同类型&子类的类型（比如number的子类是integer和float）

2.为什么使用arrays？
在同一个名字下存储多个数据；通过index获取；适用于循环和批量处理

3.Array的声明
Typ[] nameDerVariable = new Typ[ LängeAlsGanzzahl ];

4.在array只声明，不初始化时：
Integer[] a;‼️此时这个array不存在，如果你要给其中一个位置初始化a[0] = 4; -> 会报错
此时也不能调用和这个array属性相关的a.length 会抛出NullPointerException

5.只用标准值初始化时（只创建了array且写了长度）：
int[] a = new int [5]; 此时每个位置都是0（boolean-false; float-0.0f）
无法调用a[i].method()/a.attribute  ->  会抛出NullPointerException

6.填充array的元素：
int[] zahlen = new int[5];
for (int i = 0; i < zahlen.length; i=+) {
	System.out.println(zahlen[i]);
}
Alternativ：
for (int zahl : zahlen) {
	System.out.println(zahl);
}
‼️for (Type elementName : arrayName){
	System.out.println(elementName);//自己取的elementName
}


7.多维arrays（二位数组中的结构形式）
rechteckig矩形状：int[][] a = new int[2][9] (矩形2x9)
jagged锯齿状：
int[][] b= new int[2][];///只确认外层元素
b[0] = new int[4];///第一行4个元素：内层元素确认
b[1] = new int[2];///第二行2个元素


8.arrays常见的报错：
ArrayIndexOutOfBoundsException：index在有效边界外（一般发生在：循环边界错误）
NullPointerException：调用了未初始化的array或者元素（只声明了，但是未初始化，即使声明了长度）
错将length写成length();
不相容的元素类型:声明的数组类型与元素类型不符；
arrays的打印方法：
1️⃣
int[][] matrix = {{1, 2}, {3, 4}};
for (int i = 0; i < matrix.length; i++) {
	for (int j = 0; j < matrix[i][j].length; j++) {
    	System.out.print(matrix[i] + " ");
	}
    System.out.println();/////这是换行
}
输出：
1 2 
3 4 
2️⃣Arrays.toString(a);这是系统自动打印！！！！只输出一行且无法控制输出格式
比如一维数组：‼️int[] a = {1, 2, 3};System.out.println(Arrays.toString(a));
多位数组：int[][] b = { {1, 2}, {3, 4} };
System.out.println(Arrays.deepToString(b));‼️deepTo T也要大写




9.一维和二维的数组示例
// Eindimensionales Array (Kurzschreibweise)
int[] numbers = {1, 2, 3};
int[] zahlen = new int[3];
zahlen[0] = 1;
zahlen[1] = 2;
zahlen[2] = 3;
// Zweidimensionales Array (Kurzschreibweise)
int[][] matrix = {
{1, 2, 3},
{4, 5, 6},
{7, 8, 9}
};


10.小作业✍️
1️⃣Array-Inhalt ausgeben (for-each) 
2️⃣Summe aller Elemente berechnen
3️⃣二维数组迭代











