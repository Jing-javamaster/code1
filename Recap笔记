Recap 1 10🈷️20日


/ 除法运算 计算商      7 / 3 = 2（整数除法）或 2.333...（浮点除法）
% 取余运算 计算余数    7 % 3 = 1

code订正
1️⃣korrekte Deklaration & Initialisierung
boolean l1keTearsInTheRain;✅(只作为声明的话)

2️⃣korrekte Initialisierung
boolean d;❌因为布尔值是局部变量（在方法、if 块、for 块、while 块等里面定义的变量）。所有局部变量在使用前都必须显式赋值
char e = "e";❌ 对于char是'' ->char e = 'e';

float b = 5;✅（int->float是允许的，会自动类型提升）
float c = 5.0f;✅
Integer g = new Integer(5);✅

3️⃣
Integer a = new Integer(4);
Integer b = a;
a = new Integer(5);
// Welchen Wert hat b?
选项：
Objekt von Typ Integer mit dem Wert 5
Es gibt einen Fehler
null
5
Objekt von Typ Integer mit dem Wert 4✅
4

4️⃣
int a = (5 + 2) / 2;        a=3
float b = (3 + 4) / 3;      b=7/3
int c = (int) ((a + b) % 42);  ///强制类型转换（type cast）只保留int部分


5️⃣print和println的区别：有没有换行

System.out.print("Hello");
System.out.print("World"); ————>HelloWorld

System.out.println("Hello");
System.out.println("World");————>Hello
                                 World

6️⃣
Wie kann man den Wert der Variablen a in die Konsole ausgeben, wenn sie ein Objekt ist?
System.out.print(a.value);
System.out.println(a);
System.out.print(a.val);
Keine der oben genannten Optionen✅
System.out.print(a);
解答：
在 Java 中，对象变量保存的不是“值”，而是“引用”（即内存地址）。
此时，Java 会调用 a.toString() 方法。而默认的 toString() 输出是：类名@哈希码
所以为了输出真正的值：1.类自己覆盖（override）了 toString() 方法； 2.通过 Getter 方法访问字段❓
1.类自己覆盖（override）了 toString() 方法 意思就是在当前这个类当中，我们重写toString这个方法到我们需要的值，或者像这里例子里的名字，然后再直接打印需要的变量，就是我们需要的值


7️⃣Welche Variablen sind an der markierten Stelle im folgenden Code sichtbar?
public void testMethod(int a) {
    int b = 0;
    if (b > 0) {
        int c = 2;
    }
    // Welche Variablen sind hier sichtbar? Loesung:a,b
    int d = 1;
}
	•  a（方法参数）：整个方法体内可见 → 在标记处可见。
	•  b（在方法体内声明）：从声明处开始到方法结束 → 在标记处可见。


8️⃣第15题‼️
实际上考查的是 在println的作用域内有哪些变量
这里引申了一个{}的知识点，有时候无中生有的花括号其实是圈地自圆，就是为了隔开这种作用域在整个方法体内的方法，也就是说题目里的l它只活在花括号内

9️⃣第17题‼️
a,b,c它们定义在类体内、方法外。所以它们的作用域是：是属于整个类的所有方法中都可访问（同一个对象实例内）。

重点关注：嵌套块的作用域



Recap2 10🈷️27日

1.do-while语句 do{schleifenrumpf} while(条件); 因此循坏至少执行一次，因为检查条件在后面
2.循环语句的转化
(1)for语句及其他语句的转化
for(int i = 0; i < 5; i++){
// deinen Code hier
}

int i = 0;
while(i < 5){
// deinen Code hier
i++;
}

int i = 0;
do {
if(i > -1){
// deinen Code hier
}
i++;
}
while(i < 5);

(2)while语句及其他语句的转化
while(bedingung){
// deinen Code

for (; bedingung;){
// deinen Code
}

do{
 if(bedingung){
 // deinen Code
 }
}
while(bedingung);


3.break和continue的区别
关键字		作用对象			执行效果
break		整个循环			立即终止整个循环（跳出循环体）
continue	当前循环的一次迭代	立即跳到下一次循环（跳过当前迭代中剩余的语句）


4.for循环语句的结构
for(Initialisierung;Bedingung;Inkrement)


theorie订正
1️⃣使用for循环语句的条件：知道次数
使用while循环语句的条件：不知道次数

2️⃣for循环语句Kopf构造(Initialisierung;Bedingung;Aktualisierung‼️)

3️⃣continue不能在Schleifenrumpf以外使用，是语义错误

4️⃣break的作用：Beendet die gesamte Schleife vollständig
⚠️不是Überspringt den Rest des Schleifenrumpfs(只是跳过当前Iteration的剩余部分)
continue的作用：Überspringt den Rest des Schleifenrumpfs und geht zur nächsten Iteration

5️⃣continue和break只要在循环rumpf里面就可以，不限定循环语句类型

6️⃣for循环语句的头部三部分哪一部分是可以舍弃的？A：全部
for( ; ; ){
    // Endlosschleife !!!
}
7️⃣在一个循环的头部条件一直是true，那就会一直执行，直到手动break或者报错

8️⃣计算嵌套循环的次数：根据内层循环在每次外层迭代的时候，循环的次数是否都相同来判断，如果相同那就可以内外两层的循环次数相乘等于总循环次数，如果不同的话，那计算总循环次数就要使用加法

9️⃣❌Die innere Schleife wird parallel zur äußeren ausgeführt, was die Parallelisierung des Codes erleichtert
循环的本质是顺序执行，并不是并行执行



code订正
1️⃣
int i = 0;
while(i < 5){
    int sum = i;
    i++;
}
✅Sie durchläuft die Zahlen von 0 bis 5 und speichert den aktuellen Wert in der Variablen i

2️⃣int j = 1;
do {
    int i = 1;
    i = 5 + j;
    j *= 2;
}
while(i < 2);
✅Keine, da ein Kompilierungsfehler enthalten ist‼️🤔
因为i在花括号当中，出了花括号i就不存在，所以无法在while当中检查i的条件

3️⃣代码Äquivalenz判断标准：
如果两段循环产生的输出全相同，那么它们被视为等价（äquivalent）。

4️⃣System.out.println()：
打印一个换行符（newline），不打印任何其它字符。
==>表示换到下一行

5️⃣0 % 2 == ？
答案等于0
因为余数永远小于除数（2）。







Recap3 11🈷️3日

1.Arrays固定的speicherplatz，大小不能改变
int a[] = {1,2,3,4,5}
对于简单数据结构：只能是和自己array同类型的数据
复杂类型array：同类型&子类的类型（比如number的子类是integer和float）

2.为什么使用arrays？
在同一个名字下存储多个数据；通过index获取；适用于循环和批量处理

3.Array的声明
Typ[] nameDerVariable = new Typ[ LängeAlsGanzzahl ];

4.在array只声明，不初始化时：
Integer[] a;此时这个array不存在，会编译错误‼️在 Java 中，new int[] 这个写法必须要么指定长度，要么立刻给出初始化列表，否则编译器会不知道要分配多大的空间。
如果你要给其中一个位置初始化a[0] = 4; -> 会报错
此时也不能调用和这个array属性相关的a.length 会抛出NullPointerException

5.只用标准值初始化时（只创建了array且写了长度）：
int[] a = new int [5]; 此时每个位置都是0（boolean-false; float-0.0f）‼️
‼️无法调用a[i].method()/a.attribute  ->  会抛出NullPointerException
✅但是是合法的，只是无法调用空数组的参数和方法

6.填充array的元素：
int[] zahlen = new int[5];
for (int i = 0; i < zahlen.length; i=+) {
	System.out.println(zahlen[i]);
}
Alternativ：
for (int zahl : zahlen) {
	System.out.println(zahl);
}
‼️for (Type elementName : arrayName){
	System.out.println(elementName);//自己取的elementName
}


7.多维arrays（二位数组中的结构形式）
rechteckig矩形状：int[][] a = new int[2][9] (矩形2x9)
jagged锯齿状：
int[][] b= new int[2][];///只确认外层元素
b[0] = new int[4];///第一行4个元素：内层元素确认
b[1] = new int[2];///第二行2个元素


8.arrays常见的报错：
ArrayIndexOutOfBoundsException：index在有效边界外（一般发生在：循环边界错误）
NullPointerException：调用了未初始化的array或者元素（只声明了，但是未初始化，即使声明了长度）
错将length写成length();
不相容的元素类型:声明的数组类型与元素类型不符；
arrays的打印方法：
1️⃣
int[][] matrix = {{1, 2}, {3, 4}};
for (int i = 0; i < matrix.length; i++) {
	for (int j = 0; j < matrix[i][j].length; j++) {
    	System.out.print(matrix[i] + " ");
	}
    System.out.println();/////这是换行
}
输出：
1 2 
3 4 
2️⃣Arrays.toString(a);这是系统自动打印！！！！只输出一行且无法控制输出格式
比如一维数组：‼️int[] a = {1, 2, 3};System.out.println(Arrays.toString(a));
多位数组：int[][] b = { {1, 2}, {3, 4} };
System.out.println(Arrays.deepToString(b));‼️deepTo T也要大写




9.一维和二维的数组示例
// Eindimensionales Array (Kurzschreibweise)
int[] numbers = {1, 2, 3};
int[] zahlen = new int[3];
zahlen[0] = 1;
zahlen[1] = 2;
zahlen[2] = 3;
// Zweidimensionales Array (Kurzschreibweise)
int[][] matrix = {
{1, 2, 3},
{4, 5, 6},
{7, 8, 9}
};


10.小作业✍️
1️⃣Array-Inhalt ausgeben (for-each) 
2️⃣Summe aller Elemente berechnen
3️⃣二维数组迭代




theorie订正
1️⃣Arrays in Java：Es ist eine Datenstruktur, in der Elemente desselben Typs gespeichert werden.
Java 规定：
数组的所有元素都必须是相同的编译时类型（compile-time type）。
这句话的关键是——“编译时看来是同一类型”，
但“运行时实际存的对象”可以是这个类型的子类实例。

2️⃣在 Java 里可以创建一个长度为 0 的数组✅
Java 中数组的创建语法：Typ[] name = new Typ[ganze positive Zahl];
因为 0 也是一个整数，所以编译器不会报错，运行也正常。
⚠️只是长度为0的数组不能调用这个数组的参数和方法


3️⃣两个数组的相等性能通过==来比较❌‼️引用类型和基本类型的区别
1.数组是引用类型，用 == 比较引用类型时，比较的不是内容，而是地址（Referenz/Identität）
‼️因为 == 比较的是：“两个变量是否指向同一个对象（同一个 Speicheradresse）”。
如果想要比较两个数组的内容是否相等，System.out.println(Arrays.equals(a, b)); // 比较a、b两个数组
（多位数组）System.out.println(Arrays.deepEquals(a, b));


引用类型（Reference Type） 是一种变量，它不直接存储数据本身，而是存储数据在内存中的地址（引用）。

类型类别							举例															存的是什么				存在哪里
基本类型 (Primitive Types)		int, double, boolean, char, …								直接存储值本身				栈 (Stack)
引用类型 (Reference Types)		String, 数组 (int[], String[]), 对象 (Person, Scanner)		存的是对象在堆里的地址		栈上存引用，堆上存对象

比如说：
基本类型int a = 5；  -> a 里真的就是数字 5
引用类型像是一个“信箱号”，里面装的是地址：String s = "Hello";
s 变量里存的不是 “Hello”，而是“Hello” 在内存中那块区域的地址（引用）。



4️⃣数组的优点：Einfache und schnelle Zugriffsmöglichkeiten über Indizes✅

Sie speichern Daten dauerhaft auf der Festplatte❌数组是内存（RAM）里的临时数据结构。程序结束后数组消失，除非你显式地把内容写进文件（那是 IO 操作，不是数组的功能）。


5️⃣Was passiert, wenn man versucht, auf ein Element außerhalb des gültigen Indexbereichs zuzugreifen?
Es wird eine Exception zur Laufzeit ausgelöst（程序运行时会抛出一个异常）✅

Das Programm wird kompiliert, aber mit Warnung❌
“编译通过” 就是说 —— 这段代码在语法上合法，编译器能把它翻译成可执行的字节码。
它不会报“Syntax Error”，但不代表程序运行时不会出错。



Codefragen
1️⃣数组声明：必须要么指定长度，要么立刻给出初始化列表。 ｜
否则编译器会不知道要分配多大的空间，compiler错误	    ｜
‼️但是数组可以只声明int[] a;合法✅				｜
但是不能半吊子声明int[] a = new int [];此时<—————｜

2️⃣数组长度为0可以访问length，只有当没有给定长度时-> NullPointerException

3️⃣一个数组只给定了长度，没有初始化，那么此时打印某一个元素可以吗？看类型分情况‼️
1.基本类型数组int，boolean，float....可以
2.引用类型数组String.....可以打印元素但是运行时抛 NullPointerException⚠️


4️⃣Ausgabe？
int[] arr = new int[5];
arr[4] = 5;
System.out.println(arr[42 % arr.length]);
答案：0


5️⃣Ausgabe？🤔
int[] arr = new int[0];
for (int num : arr) {
    System.out.println(num);
}
答案：什么都没有
‼️这里代码本质上等于
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    System.out.println(num);
}
所以循环条件 i < arr.length 一开始就为 false。
循环体根本不会被执行一次。
控制台什么都不会输出。


6️⃣Ausgabe？
int[] arr = {1, 2, 3};
for (int num : arr) {
    num = num * 2;
}
System.out.println(arr[0]);


for (int num : arr)这句话等价于：
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    num = num * 2;
}
答案是：1
关键点 ⚠️：num 只是 arr[i] 的一个副本（copy）。修改 num 不会反过来改变 arr[i]。
---> 数组 arr 完全没有被修改。



7️⃣Ausgabe？
int[] arr = null;❓我想问这里给数组赋值null是等同于建立了一个长度为0的数组吗？A：一个是“什么都没有”，另一个是“有东西，但里面空”。arr 指向一个长度为 0 的数组对象
for (int num : arr) {
    System.out.println(num);
}
答案是： NullPointerException



‼️‼️‼️首先要理解：增强型 for 的本质
增强 for 循环其实是编译器帮你自动生成的代码，
等价于：
for (int i = 0; i < arr.length; i++) {
    int num = arr[i];
    System.out.println(num);
}

在执行 for-each 前，Java 会先去调用：
arr.iterator()   // 对集合
arr.length       // 对数组
但是arr 是 null，所以一旦访问 .length就会抛出：NullPointerException











Recap3 11🈷️10日
1.类的作用：Information和Methode的Container
类定义：
	属性：描述对象的状态
	方法：描述对象可以做什么

2.Konstruktor构造器
你可以在同一个类中定义多个构造函数，只要它们的参数列表不同即可。
也就是构造函数可以被重载（überladen）。
例如：
class Auto {
    Auto() {}                  // 无参构造
    Auto(String marke) {}      // 一个 String 参数
    Auto(String marke, int bj) {} // 两个参数
}


3.构造方法的时候使用this把参数赋值给属性
也就是说 如果我们在构造一个方法的时候 传进来的参数名和我们需要构造的属性名字一样，那么把参数赋值给这个属性的时候使用this，不同就不用使用this
例如：
public Student(String n, int matrikelnummer) {
    name = n;                        // ❶
    this.matrikelnummer = matrikelnummer;  // ❷
}


4.this的作用：对当前对象的引用
1️⃣在对象方法和构造函数中使用
2️⃣指向当前运行该方法的对象。
3️⃣用于区分同名的属性和参数。
4️⃣‼️在静态方法中不允许，因为没有对对象的引用！


5.static的作用：
1️⃣静态元素（属性/方法）属于类，而不是单个对象。
2️⃣所有对象共享相同的静态属性值（参见第 5、9 页）。
3️⃣通过类名而不是通过对象调用。


6.final的作用
1️⃣最终变量 - Wert bleibt konstant
2️⃣final method - 不能override重写
3️⃣final class - 类不能继承（扩展）


7.其他的访问修饰符
‼️图



8.继承：一个类可以扩展（继承）另一个类。
1️⃣父类的所有方法和属性都是继承的（除非它们是私有的）。
2️⃣您可以在子类中创建新的方法、属性和构造函数
3️⃣您可以覆盖现有方法（意思是：当一个类继承了另一个类后，子类可以重新定义父类里已有的方法，）
4️⃣一个类只能继承一个类！



9.override重写和overload重载区别
1️⃣重写出现在继承关系（父类和子类之间）中：
	•	方法签名完全相同（名字、参数、返回类型、修饰符都相同）
	•	但方法内部实现不同

2️⃣重载出现在同一类中：
	•	同一个类里（derselben Klasse）
	•	方法名相同，但：
	•	参数个数不同，或
	•	参数类型不同，或
	•	访问修饰符不同
	•	功能：让同名方法有多种“输入形式”


✅一句话总结：
重载（Überladen） = 同类中，同名不同参数；
重写（Überschreiben） = 子类中，完全同名同参‼️但重写实现。


10.静态类型和动态类型‼️‼️很难
静态类型：
1️⃣在编译时设置。
2️⃣决定允许访问哪些方法和属性（对于对象）。
3️⃣换句话说，它限制了动态类型对外界可见的内容。
动态类型：
1️⃣在运行时确定。
2️⃣决定实际执行方法的哪个实现。
3️⃣包含具体对象的属性和构造函数逻辑的具体值。


11.多态
在运行时（Laufzeit），程序根据**对象的真实类型（dynamischer Typ）**来决定调用哪个方法，而不是根据引用的声明类型（statischer Typ）。见下⬇️

例如：
class Animal {
    void makeSound() {
        System.out.println("sound");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("wow");
    }
}

Animal a1 = new Animal();
Animal a2 = new Dog();

a1.makeSound(); // 输出 sound
a2.makeSound(); // 输出 wow

‼️比如这里a2声明是Animal但是实际运行的时候引用的是一个 Dog 对象，所以输出wow
‼️‼️但是❗️但这个原则只适用于：子类重写（Überschreiben）父类已有的方法。‼️它不适用于访问子类‼️新增加的方法。
public class Tier {
    public void laufen() {
        System.out.print("Das Tier läuft. ");
    }
}

public class Hund extends Tier {
    public void bellen() {///🆕新增加的方法
        System.out.print("Der Hund bellt.");
    }
}
Tier t = new Hund();
t.laufen();
t.bellen();❌

👉 为什么这次不行？
编译时：编译器看静态类型 Tier，去找有没有 bellen() → ❌ 没有
所以代码根本编译不过，根本还没到“运行时”的阶段。

换句话说：
多态只在**“共同‼️存在于父类和子类”**的方法之间起作用。‼️‼️
如果父类根本没这方法，编译器连“多态的入口”都找不到。


🤔那多态起到一个什么作用呢？静态声明不同，让他在运行的时候看实际的类型。
1️⃣让同一套代码可以处理不同的对象类型
2️⃣让程序更灵活、更可扩展
3️⃣隐藏实现细节（接口抽象）




12.继承和构造器
子类不会继承父类的构造函数，但每次创建子类对象时，父类构造函数一定会先被执行。
若父类没有默认构造函数，就必须在子类构造函数第一行显式写 super(...)。
class Parent {
    Parent(int x) {} // 只有有参构造函数
}

class Child extends Parent {
    Child() {
        super(10); // ✅ 必须显式调用，因为父类没有默认构造
    }
}
🔸 而且：
super(...) 必须是子类构造函数的第一行语句！
否则编译会报错。

默认构造函数：没有参数的构造函数。
如果你没有写任何构造函数，Java 编译器会自动为你生成一个这样的无参构造函数。
例如：
我们写没有参数的构造函数
class Cat {
    String name;
}
Java 会自动生成一个：
Cat() { }      这就是默认构造函数

‼️也就是说：如果父类自己构造了一个有参函数，那么子类必须在第一行写super;父类如果是无参函数，也就是父类有默认构造函数，那么super就可以不用写，编译器会自动提供
🧐为什么要这么做？
因为一个子类对象，其实是“包含了父类部分 + 子类部分”的一个整体结构。
你要建二楼（子类对象）时，必须先让一楼（父类）结构稳定（super()），否则二楼建上去就坍塌。
让父类结构稳定，也就是让父类的属性先初始化，所以在父类自己没有默认构造函数的时候，需要我们自己写super来初始化父类属性


13.Objekt：是所有类的父类

每个类都会自动继承自 Object，即使您不编写扩展。
这意味着 - 每个类都继承了 Object 的基本方法，例如：

toString() → 返回对象的字符串表示
equals(Object o) → 比较对象内容是否相等
hashCode() → 返回对象的哈希值（数值表示）
getClass() → 返回对象的运行时类型（类信息）


……各个Module的Code实现





Theorie订正：
1.什么是Konstruktor？
Konstruktor（构造函数） 是一种特殊的方法，用来在创建对象时（new）初始化对象的属性。

它是对象“出生”时自动执行的第一段代码，负责把对象从一块空内存变成一个可用、有内容的实例。

class Cat {
    String name;
    int age;

    // 这是构造函数
    Cat(String n, int a) {
        name = n;
        age = a;
    }
}


8.见上面笔记11.多态：此时不是override了父类的方法，而是子类的新增方法，所以只看运行时候的实际类型并不适用






Codefragen订正：
1.
public class Oberklasse {
    public Oberklasse() {
        System.out.println("Konstruktor der Oberklasse; ");
    }
}

public class Unterklasse extends Oberklasse {
    public Unterklasse() {
        System.out.println("Konstruktor der Unterklasse; ");
    }
}

输入：Unterklasse u = new Unterklasse();
请问会输出什么？
答案：Konstruktor der Oberklasse;Konstruktor der Unterklasse; 

因为：
1️⃣ 首先调用 Unterklasse 的构造函数
→ 构造函数第一行隐式包含 super()
2️⃣ 所以先去执行 Oberklasse 的构造函数
→ 输出 "Konstruktor der Oberklasse; "
3️⃣ 然后再执行子类构造函数里的代码
→ 输出 "Konstruktor der Unterklasse; "



2.这两个方法能共存吗？（能否构成“重载”）
public class Test {
    public int add(int a, int b) {
        return a + b;
    }

    public void add(int a, int b) {
        System.out.println(a + b);
    }
}

判断标准：Signatur相同，实现不同
在 Java 中，方法的唯一标识（签名）是由以下两部分组成的：方法名 + 参数列表（类型与数量）

⚠️ 不包括：
	•	返回类型（int、void 等）
	•	修饰符（public、private）
	•	抛出异常类型
也就是说：→ 两个方法的签名完全相同，返回类型不同而已。
Java 不允许仅靠“返回类型不同”来区分两个方法。因此会出现编译错误


3.Beim Überschreiben kann die Sichtbarkeit der Methode verringert werden❌
Sichtbarkeit可见度降低，也就是protected改成private 不允许








Recap4 11🈷️17日

前情回顾：（摘自Java自学笔记-Readme）
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
10.3
接口中所有都是抽象方法，不可以有正常方法
接口中所有方法都是public
所以这种情况下的public abstract是已经默认、可以省略的

public interface 接口名 这里的interface是声明他已经不是类，但是跟类很像
接口靠类实现
能继承接口的只能是接口，接口和类只能是实现关系implements
单继承，多实现
接口中所有变量都是全局静态常量（也就是final 不能重新赋值）

那么问题来了，一个实现接口的类和一个实现抽象类的子类是完全等同的吗？
不是：	
1.	继承方式不同
	•	类只能继承一个抽象类（单继承）。
	•	类可以实现多个接口（多实现）。⚠️（是对于类来讲 单继承：只能继承一个 多实现：能实现多个）
2.	内容不同
	•	抽象类可以有：构造器、普通方法、字段。
	•	接口早期只能有：抽象方法。
	•	Java 8+ 接口可以有 default 方法（带实现）、static 方法。
3.	设计目的不同
	•	抽象类 = 表达“是一种（is-a）”关系。
（例：Dog extends Animal → 狗是一种动物）
	•	接口 = 表达“能做什么（can-do）”关系。
（例：Dog implements Runnable → 狗能跑）

1.对比理解
你可以这样类比：
	•	抽象类 → 模板：规定“家族共性”，但不完整，子类要补全。
	•	接口 → 契约：规定“功能规范”，实现类要签合同，承诺“我要实现这些功能”。

	•	实现接口的类 可以同时实现多个接口，而继承抽象类只能一个。
	•	接口里方法的“抽象”更纯粹（早期没有任何实现），抽象类则是“抽象+部分实现”的混合体。
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


1.抽象类不可以创建对象：因为抽象类是不完整的类，因为抽象方法没有实现
创建对象 = 必须保证对象的所有行为都是可执行的。

2.抽象类和接口的应用情况：多个类具有相似的任务，但实现不同
抽象类/接口可以抽出通用部分，避免重复代码

‼️
class Dog { void makeSound() { bark } }
class Cat { void makeSound() { meow } }
class Bird { void makeSound() { tweet } }

✅抽象类例子：
你把共同的东西放到抽象类里：
abstract class Animal {
    void eat() { ... }      // 通用实现
    void sleep() { ... }    // 通用实现
    abstract void makeSound();
}


再让具体类继承：
class Dog extends Animal {
    void makeSound() { bark }
}

class Cat extends Animal {
    void makeSound() { meow }
}



✅接口例子：

class Bird extends Animal { }
class Plane extends Machine { }
class SuperMan extends Human { }
它们没有任何共同的父类（除了 Object），但都能“飞”。
这时你不能用抽象类（因为抽象类只能单继承，这里他们已经有父类了‼️）。
🤔‼️也就是说在几个子类已经继承到不同的特定类，并且有共同逻辑->接口

接口：
interface Flyable {void fly();}

让具体类实现
class Bird extends Animal implements Flyable {}
class Plane extends Machine implements Flyable {}
class SuperMan extends Human implements Flyable {}

同一个类体系 → 用抽象类
不同类体系 → 用接口


3.抽象类当中可以没有抽象方法‼️

因为 Java 的规则是：
只要类被声明成 abstract，就不允许实例化。
至于里面有没有 abstract 方法，是两回事。


4.对于抽象类的子类：‼️
子类应当实现所有‼️抽象方法。
如果子类没有实现所有抽象方法，也必须声明为抽象类！ 


5.接口：
仅包含方法签名；无构造器‼️；所有字段均为public static final字段（即常数）‼️
一个类可以实现多个接口‼️；所有方法都是公有的‼️

如果想让接口能增加新方法，而不会让所有以前的实现类报错，用default‼️
————> 所有没有覆盖这个方法的子类都会自动使用它。
为什么这样子？是为了让接口在现代 Java 中变得“不那么僵硬”，具备一点点抽象类的能力（代码复用），以提升灵活性和可扩展性。



6.抽象类和接口的共同之处：
不能实例化，也就是不能创建对象；

可以作为静态类型使用，但不能作为动态类型使用。
Animal a = new Dog();
↑静态类型   ↑动态类型
也就是说：你可以用“接口”或“抽象类”当作变量的类型（左边），但你不能 new 它们（右边）。
✅
Animal a;         // 抽象类作为静态类型 OK
Moveable m;       // 接口作为静态类型 OK

Animal a = new Dog(); 
Moveable m = new Robot();
❌
new Animal();   // 抽象类不能作为动态类型（不能被实例化）
new Moveable(); // 接口不能作为动态类型（不能被实例化）



7.课件第13页错误的原因是：Animal是抽象类，不能实例化，不能new‼️
课件第15页：子类继承一个抽象类，实现一个接口，但只实现了抽象类中的抽象方法，接口中的没有实现，那么这个子类为抽象类




8.一个类是否能实例化（能不能 new）取决于它是否是“完整类”。

“完整类”意味着：
	•	没有任何尚未实现的方法
	•	没有任何 abstract 方法
	•	父类和接口中要求实现的方法全部已经实现
	•	逻辑上可以正常执行所有方法

只要满足这些 → 就可以 new。



9.为什么接口不能有构造器而抽象类可以？
构造器存在的意义只有一个：初始化对象的状态（字段）。
接口没有对象 → 所以不需要构造器
🤔但为什么抽象类可以有构造器，它也不能有对象？
因为抽象类本质是“一个不完整的类”，但仍然是“类”‼️。接口不是类，它是能力描述。‼️



10.匿名类：没有自己的名字/只能实现一次/不能定义构造器（因为没有类名）

abstract class Animal {
abstract void doSound();
}

Animal cat = new Animal() {
    void doSound(){ System.out.println("Myao"); }
};
你在 new 的不是 Animal。
因为 Animal 是抽象类，不能 new。

👉 你实际上是在 new 一个“临时生成的子类”。‼️
这个子类继承 Animal，并实现了 doSound()。

👉 但这个子类没有类名。






Theorie订正：
1.抽象类和接口的主要目的：
Eine abstrakte Klasse bildet die Grundlage für eine Klassenhierarchie.抽象类用来建立一个“类族谱”（继承体系）。
Ein Interface definiert welche Methoden oder Funktionalitäten eine Klasse bereitstellen muss. 接口定义“这个类必须能做什么”。

2.Alle Methoden in einem Interface sind automatisch public✅在 interface 里，方法的访问修饰符永远都是 public，即使你不写，Java 也会自动当作 public。
Ein Interface kann mehrere andere Interfaces erweitern‼️接口居然可以继承多个接口，单继承多实现只是对类，单继承一个类，多实现多个接口
Ein Interface kann (seit Java8) Methoden mit Implementation enthalten

❓为什么接口可以继承多个接口？
因为接口没有字段、构造器、复杂实现 → 不会有冲突 → 能做能力组合。‼️


3.抽象类和接口的共同之处
Beide können mehrere Interfaces implementieren/erweitern‼️这里的erweitern‼️是继承的意思😓
Beide können nicht direkt instanziiert werden
Beide können konkrete (implementierte) Methoden enthalten







Codefragen订正：

1.❌
public abstract class MyBot{
    private abstract int xPosition;
    private abstract int yPosition;
    
    public abstract MyBot(int x, int y);
}

抽象类可以没有抽象方法，比如
abstract class A {
    void f() {}
}
但是这里的问题不是这个，1.是字段不能是abstract‼️2.构造器不能是 abstract‼️
1️⃣因为：
字段本质是数据（数据不可能“未实现”‼️）
abstract 的意义是“必须由子类实现”
字段没有“实现”‼️，只有“值”
所以字段不可能被标记为 abstract✅

2️⃣因为：
abstract = “由子类实现”
构造器 = “初始化这个类自身”
构造器不能被继承，所以子类无法 override 构造器
→ 所以也不可能 “实现” 父类的抽象构造器

构造器不能被继承是因为：构造器本质是“初始化当前类自身的内部结构”。这个初始化动作不能被子类复用

记住：
类中只有两种东西可以标记 abstract：
	1.	抽象类本身
	2.	抽象方法（没有方法体）



2.❌
interface IntSolver{
    int solve(int first, int second);
}‼️接口中的方法自动 = public abstract

class Addierer implements IntSolver {
    int solve(int first, int second){///❌但这里的没有写public → 默认是 package-private（包可见）。
        return first + second;
    }
}
也就是说：
	•	接口方法：public
	•	实现方法：默认可见（更弱）




3.❌
interface A{
    default void apply(){
        System.out.print("Alice");
    }
}

interface B{
    default void apply(){
        System.out.print("Bob");
    }
}
C继承两个interface，c.apply()会输出什么？
答案：Ein Fehler

为什么不能自动同时调用两个？
不行，因为：
	•	Java 的继承规则不允许自动合并 default 方法的行为
	•	default 不是“合并行为”，只是一个轻量实现
	•	多继承冲突必须人工解决
这是 Java 为了避免模糊行为而强制的规则。

有Namenkonflikt必须手动消除：
✅
class C implements A, B {
    @Override
    public void apply() {
        A.super.apply();   // 或者 B.super.apply()
        // 或两者都调用，你自己决定
    }
}

🤔为什么必须用 A.super.apply() 这种奇怪的写法？
这背后是 Java 为了解决多接口 default 方法冲突而设计的一个 专用语法。
没有这个语法，编译器根本不知道你想调用哪一个 default 方法。

‼️因为类可以实现多个接口，Java 需要你明确选择调用哪一个接口的 default 方法，所以语法必须写成 InterfaceName.super.method()










Recap5 11🈷️29日
Thema 5 - Interfaces und abstrakte Klassen






















Recap6 12🈷️08日
Thema 6 - Grundlagen der funktionalen Programmierung

1.Racket
1️⃣核心思想：你把所有东西当“数学函数”一样使用，不去修改状态，不到处赋值。
2️⃣来自 Lisp 家族 → 所以它长得像这样：❓
(+ 1 2)
(define (f x) (* x x))
❓：所谓 Lisp（LISt Processor），本质就是：整个程序就是一棵树，而‼️树在文本中的表示方式就是括号嵌套‼️的列表‼️。
我们只要一种结构 —— List。其他所有东西（语句、函数、表达式）都由它组成。
‼️因为这样的结构非常适合递归求值
解析规则非常统一：
要计算一个表达式＝
① 计算列表第一个‼️元素（必须是函数/操作符） ‼️：所以适合递归求值
② 递归地计算其他元素
③ 调用函数

‼️
1️⃣cons 的作用就是“把一个元素放在列表头部”
cons = prepend（前置）
= “把某个东西放到列表最前面”
(cons 'a '(b c d)) ; => '(a b c d)
(cons 100 empty)   ; => '(100)
2️⃣匿名函数
匿名函数 = 没有名字的函数。
就是临时用一下、不想定义成独立函数的函数。
3️⃣' 符号 是 Racket/Lisp 的“quote”的缩写
quote = 不要计算里面的表达式，把它当成原始数据。

4️⃣(cons (map (lambda (x) (* x x)) '(2 3))
      '(10 20))
答案：'((4 9) 10 20)
❓为什么输出一个列表 而前面还带quote
作用：REPL 用 ' 来告诉你：“我显示的这个东西是数据（list），不是代码（function call）。” 用 quote 只是避免误解，让你一眼看出它是列表字面量。
比如我们输入：(list 1 2 3)
Racket会输出：'(1 2 3)
但内部值实际是：(1 2 3)

5️⃣：define
(define (name Parameterliste) (Implementation))
🌰例子：
(define (add a b) (+ a b))
(add 2 3) ; Aufruf der Methode

6️⃣Listen
(define lst '(1 2 3 4)) ; erstellt eine geordnete Liste mit den Elementen 1, 2, 3, 4
(first lst) ; liefert erstes Element der Liste: 1
(rest lst) ; liefert Rest der Liste ohne das erste Element: (2, 3, 4)
(cons 0 lst) ; fügt 0 vorne an die Liste an
(length lst) ; Anzahl der Elemente
(append lst '(5 6)) ; Listen verketten
‼️append 不会在尾部直接拼接（因为是单链表），而是复制 + 拼接，创建新列表
行为是：创建一个新的链表，先复制 lst 的所有节点，再接上 (5 6)。
结果：'(1 2 3 4 5 6)
仍然不修改 lst 本身。‼️
(empty? lst) ; prüft, ob eine Liste leer ist und gibt #t oder #f aus.

Hinweis:
Listen sind unveränderlich – neue Listen werden durch cons oder append erstellt.

7️⃣Rekursion

(define (factorial n)
(if (= n 0)
1
(* n (factorial (- n 1)))))
(factorial 5) ; 120

Hinweise:
● In Racket gibt es auch tail recursion für bessere Speicheroptimierung
⚠️这里的不是尾递归
所以递归调用后还有事要做 → 不是尾调用。
尾递归 = 函数的最后一步是递归调用，而且调用完之后本层不再进行任何运算。
也可以理解为递归在尾（后续没有任何其他运算）调用之后不再执行任何其他操作。



❌Theorie订正：写了但是没有保存下来❌




Codefragen订正：

1.
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

Welcher Lambda-Ausdruck kann dieses Interface implementieren ?
a.(Integer a, Integer b) -> { a + b }❌ 重点在这个{} 这是一个代码块，代码块lambda不会自动return‼️
b.(Integer a, Integer b) -> { return a + b; }✅参数类型可以靠自动拆箱(unboxing)兜底
c.(a, b) -> a + b✅表达式lambda ->自动return

参数类型的推断来自函数式接口的方法签名，所以只要接口有好好写明白就可以自动推断出来类型。

‼️看到 lambda 直接问自己三件事：
有没有 {}？			有 → 必须手动 return
参数类型能不能推断？	能 → (a, b) 永远最安全
返回值最终类型对不对？	看“算完之后”，不是看参数


2.
List<String> names = List.of("Alice", "FOPBob", "Charlie");
Welcher Ausdruck gibt jeden Namen aus?

a.names.forEach(System.out::println);✅
b.names.forEach(name -> { System.out.println(name) });❌
c.names.forEach(name -> System.out.println(name));✅


‼️forEach(Consumer<? super T>)
Consumer<? super T> 的意思是：给我一个“至少能接收 T”的 Consumer，我会把 T 交给它用。
Consumer<T>
Methode: void accept(T t)	Verbraucht einen Wert T, führt eine Aktion aus, gibt aber nichts zurück


看到 lambda，先问 接口方法返回什么：
	•	返回 void
→ 不管有没有 {}，都不需要 return
	•	返回非 void
→ 有 {} 就必须 return


是否需要 return，只取决于接口方法的返回类型，和有没有 {} 没有本质关系。


4.Java里字符串如何比较：String.compareTo(String)

从左到右，一个字符一个字符比，用字符的 Unicode 值 比大小

返回值的意义：
返回负数 → a 排在 b 前
返回 0 → 两个字符串在“排序意义上相等”
返回正数 → a 排在 b 后

但“前 / 后”的依据是：字典序（lexicographical order）。

🌰1:
BiFunction<String, String, Integer> compare = String::compareTo;
int result = compare.apply("apple", "pen");
A：返回-1

🌰2:
"apple".compareTo("banana")   // < 0  ('a' < 'b')
"app".compareTo("apple")      // < 0  (前缀更短 → 更小)
"Zoo".compareTo("apple")      // < 0  ('Z' < 'a')	⚠️大写字母 < 小写字母（Unicode 决定的）











Recap7 1🈷️19日
Thema 7 - Fehlerbehandlung


1️⃣Exception的两种类型：区别在于编译器是否强制你处理
checked：继承自 Exception，但不是 RuntimeException	——>	 必须在编译期处理
🌰：IOException，SQLException
unchecked：继承自 RuntimeException   ——>	 编译器不强制处理
🌰：NullPointerException，ArithmeticException， IndexOutOfBoundsException


2️⃣
RuntimeException(逻辑错误)可以通过更好的代码避免
🌰：NullPointerException, IllegalArgumentException, IndexOutOfBoundsException.

Error(❌系统存在严重问题，不是正常错误处理的一部分)
🌰：OutOfMemoryError，StackOverflowError

3️⃣try-catch-finally
try：// 可能抛异常的最小代码块（但不一定抛），try 不是“一定会出错”，只是“允许出错”，最可能出错的代码块部分
catch：// 只能捕获 try 块中抛出的、并且‼️类型匹配的异常。
finally：// 一定执行（几乎）
⚠️唯一几个例外：System.exit(...) / JVM 直接崩溃

try -> 正常 -> finally
	-> 报错 -> catch（不管ca没ca到）	-> finally

try 抛异常
→ 所有 catch 尝试匹配（失败）
→ 执行 finally
→ 异常向外抛（当前方法直接结束）

4️⃣catch内部的Exception顺序至关重要‼️
首先必须处理特定的例外类，然后是一般例外。或者子类排在前面，父类排在后（否则问题的具体描述会因泛化而丢失）。
❓那为什么不直接写父类，子类反正也包含进去了？
A：这里的意思是，如果有 多个catch并且存在继承关系的话，那么需要按照子类在前父类在后的顺序来写。

try {
// ...
} catch (IOException e) {
	// IO Fehler
} catch (NullPointerException e) {
	// Null-Fehler
}

那么哪些是特定哪些是一般例外呢？
看继承关系，父类是一般例外，子类是特定例外
•Throwable
	•Exception
	   •RuntimeException
			•NullPointerException
			•IllegalArgumentException

5️⃣multi-catch
try {
	// ...
} catch (IOException | SQLException e) {
	e.printStackTrace();‼️这叫相同的处理逻辑
}
适用情况：相同的处理逻辑并且‼️没有继承关系的话

6️⃣
public class MyException extends Exception {
	public MyException(String message) {
		super(message);
	}
}
这里super(message)的作用？
由于子类对象中包含父类的状态，在构造子类对象时必须先调用父类构造器，以便由父类自身完成其部分的初始化；因此在自定义异常中通过 super(message) 将参数传递给父类构造器。

7️⃣throw和throws
throw：抛出异常
throws：声明可以抛出异常

public void checkAge(int age) throws‼️ IllegalArgumentException {
	if (age < 18) {
		throw‼️ new IllegalArgumentException("Zu jung!");
	}
}

8️⃣常见误区
1.finally funktioniert ähnlich wie else und wird nur ausgeführt, wenn keine Exception geworfen wurde.❌
finally是不管怎么样都会执行的

2.Alle Exceptions müssen behandelt werden.❌
只有 checked exception（受检异常）才“必须处理或声明”
unchecked exception（RuntimeException 及其子类）可以不处理

‼️3.catch(Exception e) ist eine universelle Lösung.❌
universell在可以全部接住，但是并不能全部解决，因为具体异常具体分析，不可能有万能解能解决所有类型的异常

4.finally ist nicht notwendig, wenn einer der catch-Blöcke garantiert ausgeführt wird.❌
catch 不是保证执行的
finally 才是唯一的“清理保证”

5.Error sei eine Unterklasse oder eine Oberklasse von Exception.❌
Error和Exception是Throwable的子类，他俩平行

6.In jedem catch-Block muss die Variable anders heißen, um Compilerfehler zu vermeiden.❌
都可以叫e没关系
try { ... }
catch (IOException e) { ... }
catch (SQLException e) { ... } // ✔ 完全合法

7.Man kann in multi-catch beliebige Klassen zusammen kombinieren.❌
必须是处理逻辑完全相同并且没有继承关系的异常类型







Theoriefragen订正：
1.Warum schreiben wir die ganze Klasse oder den gesamten Code in try-catch-Blöcke nicht?
a.Doch, es ist möglich und ist eine gute Praxis❌
b.Verstecken von Fehlern - unerwartete Fehler werden ignoriert✅⚠️
因为！
try {
    // 整个程序
}
catch (Exception e) {
    // 什么都不做 / 只打印一句
}
结果是：
	•	本来应该暴露的 bug
	•	被你 catch 掉了
	•	程序“假装还能跑”‼️
👉 这就叫“错误被隐藏”
c.Unklare Fehlerbehandlung - es wird schwierig zu erkennen, welcher Teil des Codes Fehler verursacht hat✅
d.Verschlechterte Performance (Leistung) von Programm✅

2.Worin besteht der Unterschied zwischen checked und unchecked Exceptions in Java?
a.Checked Exceptions müssen entweder mit try/catch behandelt oder im Methodenkopf mit throws deklariert werden. 
Unchecked Excpetions kann man vorhersagen, darum müssen sie auch nicht behandelt werden.✅
b.Beide Arten von Exceptions müssen mithilfe der throws-Clause behandelt werden, 
aber eine checked Excpetion wirft man selbst mit "throw", und die unchecked Exceptions wird Java bei Bedarf selbst werfen.❌两种异常都能手动werfen或者Java bei Bedarf selbst werfen
⚠️Checked Exceptions 必须在编译期通过 try/catch 或 throws 处理；
Unchecked Exceptions 不受编译器强制。
Checked Exceptions 通常表示可恢复的外部错误，
而 RuntimeExceptions 多为编程错误。
c.Checked Excpetions geben wiederherstellbare Fehler/ Zustände des Programms wieder, 
während RuntimeExceptions eher Programmierfehler sind, die manchmal schwer nachvolziehbar sind.✅

3.Was passiert, wenn eine Exception in einem try-Block geworfen wird, aber kein passender catch-Block vorhanden ist?
a.Falls vorhanden, wird der finally-Block ausgeführt.✅
b.Die Exception wird weitergegeben (propagiert), und das Programm kann abstürzen, wenn sie nicht abgefangen wird.✅finally的执行和程序坠毁不矛盾。
c.Die Exception wird ignoriert, und das Programm läuft normal weiter.❌





Codefragen订正：
1.在throws（声明）的时候可以直接写父类而不是详细地写到子类

2.后缀自增x++的意思是：
先使用“旧值”，再把变量加 1

写法			执行顺序			表达式的值		变量最终值	
++x			先加 1，再用		新值				新值				
x++			先用，再加 1		旧值				新值

3.
try{
    sample();
}
catch (FileNotFoundException e) { ... }
catch (NoSuchMethodException e) { ... }
catch (NullPointerException e) { ... }

在multi-catch的时候，使用同个变量e是ok的；
变量没有继承关系所以顺序没关系



